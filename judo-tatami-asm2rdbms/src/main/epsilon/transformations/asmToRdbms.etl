import "../operations/asm/_importAsm.eol";
import "../operations/typemapping/_importTypeMapping.eol";
import "../operations/rulemapping/_importRuleMapping.eol";
import "../operations/namemapping/_importNameMapping.eol";

import "rdbms/util.eol";
import "rdbms/asm/namedElement.eol";
import "rdbms/asm/package.eol";
import "rdbms/asm/class.eol";
import "rdbms/asm/attribute.eol";
import "rdbms/asm/reference.eol";

import "rdbms/rdbms/field.eol";
import "rdbms/rdbms/table.eol";

import "rdbms/modules/class.etl";
import "rdbms/modules/attribute.etl";
import "rdbms/modules/reference.etl";

pre {
	var targetModel : RDBMS!RdbmsModel = new RDBMS!RdbmsModel();
	targetModel.version = modelVersion;
	var first : Boolean = true;
	var allElement : new Sequence();
	
	var configuration : RDBMS!RdbmsConfiguration = new RDBMS!RdbmsConfiguration();
	configuration.dialect = dialect;
	targetModel.configuration = configuration;

    // Fixing types
	for (v in RULEMAPPING!TableMappingRule.all.select(m | m.symbol.isDefined())) {

		v.opposite = v.opposite.asBoolean();
		v.lower = v.lower.asFloat().asInteger();
		v.upper = v.upper.asFloat().asInteger();
		if (v.opposite.asBoolean()) {
			v.oppositeLower = v.oppositeLower.asFloat().asInteger();
			v.oppositeUpper = v.oppositeUpper.asFloat().asInteger();
		} else {
			v.oppositeLower = -2;
			v.oppositeUpper = -2;
		}
		v.container = v.container.asBoolean();
		v.containment = v.containment.asBoolean();
		v.first = v.first.asBoolean();
		v.foreignKey = v.foreignKey.asBoolean();
		v.inverseForeignKey = v.inverseForeignKey.asBoolean();

		if (v.readOnly.isDefined()) {
			v.readOnly = v.readOnly.asBoolean();
		} else {
			v.readOnly = false;
		}

		if (v.cascade.isDefined()) {
			v.cascade = v.cascade.asBoolean();
		} else {
			v.cascade = false;
		}

		if (v.mandatory.isDefined()) {
			v.mandatory = v.mandatory.asBoolean();
		} else {
			v.mandatory = false;
		}
		v.rangeConstraint = v.rangeConstraint.asBoolean();
		v.inverseRangeConstraint = v.inverseRangeConstraint.asBoolean();
		v.joinTable = v.joinTable.asBoolean();
		
		log.debug("Rule: ");
	}
}


post {

	/*
	// All tables have to contain foreign key points to parent. - Structural semantics
	for (t in RDBMS!RdbmsTable.all) {
		for (p in t.parents) {
			var fk : RDBMS!RdbmsForeignKey = new RDBMS!RdbmsForeignKey();
			t.fields.add(fk);
			fk.uuid =  t.uuid +"_" + p.uuid + "@foreignKey";
			fk.name = "Super " + p.name;
			fk.description = "Reference to super table: " + p.name + " With ID: " + p.primaryKey.name;
			fk.sqlName = "SUP_" + p.sqlName + "_ID";
			fk.inheritenceBased = true;
    		fk.fromType(p.primaryKey);
    		fk.referenceKey = p.primaryKey;
    		fk.readOnly = true;
    		fk.mandatory = true;
			fk.foreignKeySqlName = "FK_" + md5(fk.uuid);
		}
	} */
	
	// Replacing name
	for (e in allElement) {
		// e.uuid.println("UUID: ");
		var sqlNameMapping = e.uuid.findSqlNameMapping();
		if (sqlNameMapping.isDefined()) {
			log.info("Replace sqlName in: " + e);
			log.info("   To: " + sqlNameMapping);
			e.sqlName = sqlNameMapping.SqlName;
		}
	}
}