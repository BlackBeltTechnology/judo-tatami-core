import "element.etl";


rule EReferenceToPrint 
	transform s : ASM!EReference
	to t : Map {
	guard:  (s.eReferenceType.isEntity() and s.eContainingClass.isEntity())

	/*
	if (first) {
		first = false;
		"Owner;RelationName;OppositeOwner;OppositeRelationName;Structure;Lower;Upper;Container;Containment;Opposite;OppositeLower;OppositeUpper;OppositeContainer;OppositeContainment;First".println(";");
	}

	var ref = s.eContainingClass.name + ";" + s.name + ";";
	if (s.eOpposite.isDefined()) {
		ref += s.eOpposite.eContainingClass.name + ";" + s.eOpposite.name + ";";
	} else {
		ref += ";;";
	}
	ref += s.eReferenceType.isStructure() + ";" + s.lowerBound + ";" + s.upperBound + ";" + s.container + ";" + s.containment + ";" + s.eOpposite.isDefined();
	if (s.eOpposite.isDefined()) {
		ref += ";" + s.eOpposite.lowerBound + ";" + s.eOpposite.upperBound + ";" + s.eOpposite.container + ";" + s.eOpposite.containment + ";";
	} else {
		ref += ";;;;;";	
	}
	ref += ";" + s.isFirst();
	ref.println(";"); */
	
	s.ruleMapping().toString().println( s.eContainingClass.name + "." + s.name + ": ");	
}

rule EReferenceToRdbmsTableForeignKey 
	transform s : ASM!EReference
	to fk : RDBMS!RdbmsForeignKey {
	    guard:  s.eReferenceType.isEntity() and s.eContainingClass.isEntity() and s.ruleMapping().foreignKey.asBoolean()
	     
    	s.eContainingClass.equivalent("EClassToRdbmsTable").fields.add(fk);
    	fk.name = s.name;
    	fk.uuid = s.getFQName();
    	fk.referenceKey = s.eReferenceType.equivalent("EClassToRdbmsTable").primaryKey;
		
		fk.fromType(fk.referenceKey);
		fk.mandatory = s.isMandatory();
		fk.sqlName = s.referenceIdentifierSqlName();
	    fk.foreignKeySqlName = s.referenceFkSqlName(); 

		if (s.container) {
			fk.readOnly = true;
			fk.deleteOnCascade = true;			
		} else {
			fk.readOnly = false;
			fk.deleteOnCascade = false;						
		}
		
		allElement.add(fk);		
}

rule EReferenceToRdbmsTableInverseForeignKey 
	transform s : ASM!EReference
	to fk : RDBMS!RdbmsForeignKey {
	    guard:  s.eReferenceType.isEntity() and s.eContainingClass.isEntity() and s.ruleMapping().inverseForeignKey.asBoolean()
    	s.eReferenceType.equivalent("EClassToRdbmsTable").fields.add(fk);

    	fk.name = s.eContainingClass.name.firstToLowerCase() + s.name.firstToUpperCase();
    	fk.uuid = s.getReferenceFQName();
    	
    	fk.referenceKey = s.eContainingClass.equivalent("EClassToRdbmsTable").primaryKey;
		fk.fromType(fk.referenceKey);
		fk.mandatory = s.isMandatory();
		fk.sqlName = s.referenceInverseIdentifierSqlName();
	    fk.foreignKeySqlName = s.referenceInvFkSqlName(); 

		fk.readOnly = false;
		fk.deleteOnCascade = false;			

		allElement.add(fk);
}

@lazy
rule EReferenceToRdbmsJunctionTable
	transform s : ASM!EReference
	to t : RDBMS!RdbmsJunctionTable {
	    guard:  s.eReferenceType.isEntity() and s.eContainingClass.isEntity()

	    targetModel.rdbmsTables.add(t);
		t.sqlName = s.referenceManyToManyTableSqlName();
		if (s.eOpposite.isDefined()) {
		    t.name = s.getFQName() + " to " + s.eOpposite.getFQName();
		    t.uuid = s.getFQName() + "_" + s.eOpposite.getFQName();
	    } else {
	    	t.name = s.getFQName() + " to " + s.eReferenceType.getFQName();
	    	t.uuid = s.getFQName() + "_" + s.eReferenceType.getFQName();
	    }

		t.name.println("Junct ref");
		allElement.add(t);
}

rule EReferenceToRdbmsJunctionTablePrimaryKey
	transform s : ASM!EReference
	to p : RDBMS!RdbmsIdentifierField {
	guard : s.eReferenceType.isEntity() and s.eContainingClass.isEntity() and s.ruleMapping().joinTable.asBoolean() and s.ruleMapping().first.asBoolean()
		p.table = s.equivalent("EReferenceToRdbmsJunctionTable");
		p.table.primaryKey = p;
	    p.name = p.table.name + "#id";
	    p.uuid = p.table.uuid + "#id";
		p.sqlName = "ID";
		p.fillType("JUUID");
}


rule EReferenceToRdbmsJunctionTableForeignKeyBidirectional
	transform s : ASM!EReference
	to fk : RDBMS!RdbmsForeignKey {
	guard : s.eReferenceType.isEntity() and s.eContainingClass.isEntity() and s.ruleMapping().joinTable.asBoolean() and s.eOpposite.isDefined() 
	    var mainReference;
	    if (s.name.compareTo(s.eOpposite.name) <= 0) {
	    	mainReference = s;
			mainReference.equivalent("EReferenceToRdbmsJunctionTable").field1 = fk;
	    } else {
	    	mainReference = s.eOpposite;
			mainReference.equivalent("EReferenceToRdbmsJunctionTable").field2 = fk;
	    }
	    mainReference.equivalent("EReferenceToRdbmsJunctionTable").fields.add(fk);
		
        // 		
    	fk.name = s.name;
    	fk.uuid = s.getFQName();
    	fk.referenceKey = s.eReferenceType.equivalent("EClassToRdbmsTable").primaryKey;
		fk.fromType(fk.referenceKey);
		fk.mandatory = s.isMandatory();
		fk.sqlName = s.referenceIdentifierSqlName();
	    fk.foreignKeySqlName = s.referenceFkSqlName(); 

		fk.readOnly = true;
		fk.deleteOnCascade = true;

		allElement.add(fk);
}


rule EReferenceToRdbmsJunctionTableForeignKeyUnidirectional
	transform s : ASM!EReference
	to fk1 : RDBMS!RdbmsForeignKey, fk2 : RDBMS!RdbmsForeignKey {
	guard : s.eReferenceType.isEntity() and s.eContainingClass.isEntity() and s.ruleMapping().joinTable.asBoolean() and s.eOpposite.isUndefined()
	    var junctionTable = s.equivalent("EReferenceToRdbmsJunctionTable");
	    
		junctionTable.field1 = fk1;
		junctionTable.field2 = fk2;
	    junctionTable.fields.add(fk1);
	    junctionTable.fields.add(fk2);
        	
    	fk1.name = s.name;
    	fk1.uuid = s.getFQName();
    	fk1.referenceKey = s.eReferenceType.equivalent("EClassToRdbmsTable").primaryKey;
		fk1.fromType(fk1.referenceKey);
		fk1.mandatory = s.isMandatory();
		fk1.sqlName = s.referenceIdentifierSqlName();
	    fk1.foreignKeySqlName = s.referenceFkSqlName(); 

		fk1.readOnly = true;
		fk1.deleteOnCascade = true;

		// The other side - not navigable
    	fk2.name = s.eContainingClass.name + "#" + s.name;
    	fk2.uuid = s.eContainingClass.getFQName() + "@" + s.getFQName();
    	fk2.referenceKey = s.eContainingClass.equivalent("EClassToRdbmsTable").primaryKey;
		fk2.fromType(fk2.referenceKey);
		fk2.mandatory = false;
		fk2.sqlName = s.sqlName() + "_" + s.eContainingClass.tableSqlName() + "_" + fk2.referenceKey.sqlName;
	    fk2.foreignKeySqlName = s.referenceUniFkSqlName(); 

		fk2.readOnly = true;
		fk2.deleteOnCascade = true;
		
		allElement.add(fk1);
		allElement.add(fk2);
}

