import "schema.etl";

rule CreateDataPropertyDeclaration
    transform s : ASM!EAnnotation
    to t : OPENAPI!PropertyDeclaration {
        guard: s.eContainer.isKindOf(ASM!EAttribute) and s.source == asmUtils.getAnnotationUri("exposedBy")
        
        t.name = s.eContainer.name;
        
	    var transferObjectTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
	    transferObjectTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDefinition").properties.add(t);
}

rule CreateDataPropertyDefinition
    transform s : ASM!EAnnotation
    to t : OPENAPI!Property {
        guard: s.eContainer.isKindOf(ASM!EAttribute) and s.source == asmUtils.getAnnotationUri("exposedBy")
                
        if (s.eContainer.many) {
            throw "Collection attributes are not supported";
        }

        if (s.eContainer.eAttributeType.isKindOf(ASM!EEnum)) {
            t.type = OPENAPI!JSONDataType#string;
            t.enum = s.eContainer.eAttributeType.eLiterals.collect(l | l.name);
        } else {
            switch (s.eContainer.eAttributeType.instanceClassName) {
                case 'java.lang.Boolean': continue;
                case 'boolean':
                    t.type = OPENAPI!JSONDataType#boolean;
                case 'byte[]':
                    t.type = OPENAPI!JSONDataType#string;
                    t.format = "binary";
                case 'java.lang.Double': continue;
                case 'double':
                    t.type = OPENAPI!JSONDataType#number;
                    t.format = "double";
                case 'java.lang.Integer': continue;
                case 'int':
                    t.type = OPENAPI!JSONDataType#integer;
                    t.format = "int32";
                case 'java.lang.Float': continue;
                case 'float':
                    t.type = OPENAPI!JSONDataType#number;
                    t.format = "float";
                case 'java.lang.Long': continue;
                case 'long':
                    t.type = OPENAPI!JSONDataType#integer;
                    t.format = "int64";
                case 'java.lang.String':
                    t.type = OPENAPI!JSONDataType#string;
                    // NOTE - byte format is used for base64 encoded characters, not supported yet
                    // NOTE - password format is not supported yet
                case 'java.math.BigDecimal':
                    t.type = OPENAPI!JSONDataType#number;
                case 'java.math.BigInteger':
                    t.type = OPENAPI!JSONDataType#integer;
                case 'java.time.LocalDate': continue;
                case 'java.util.Date': continue;
                case 'org.joda.time.LocalDate':
                    t.type = OPENAPI!JSONDataType#string;
                    t.format = "date";
                case 'java.time.LocalDateTime': continue;
                case 'java.time.OffsetDateTime': continue;
                case 'java.time.ZonedDateTime': continue;
                case 'org.joda.time.DateTime': continue;
                case 'org.joda.time.LocalDateTime': continue;
                case 'org.joda.time.MutableDateTime':
                    t.type = OPENAPI!JSONDataType#string;
                    t.format = "date-time";
                default:
                    log.info("Unknown attribute type: " + s.eContainer.eAttributeType.instanceClassName);
                    t.type = OPENAPI!JSONDataType#string;
            }
        }

        if (not s.eContainer.changeable) {
            t.readOnly = true;
        } else if (s.eContainer.required) {
            // Read only properties cannot be marked as required by a schema
            var transferObjectTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
            transferObjectTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDefinition").required.add(s.eContainer.name);
        }

	    s.equivalent("CreateDataPropertyDeclaration").property = t;
}

rule CreateReferencePropertyDeclaration
    transform s : ASM!EAnnotation
    to t : OPENAPI!PropertyDeclaration {
        guard: s.eContainer.isKindOf(ASM!EReference) and s.eContainer.containment and s.source == asmUtils.getAnnotationUri("exposedBy")

        t.name = s.eContainer.name;
	    var transferObjectTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
	    transferObjectTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDefinition").properties.add(t);
}

rule CreateReferencePropertyDefinition
    transform s : ASM!EAnnotation
    to t : OPENAPI!Property {
        guard: s.eContainer.isKindOf(ASM!EReference) and s.eContainer.containment and s.source == asmUtils.getAnnotationUri("exposedBy")
        
        if (not s.eContainer.changeable) {
            t.readOnly = true;
        } else if (s.eContainer.required) {
            // Read only properties cannot be marked as required by a schema
            var transferObjectTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
            transferObjectTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDefinition").required.add(s.eContainer.name);
        }

        s.equivalent("CreateReferencePropertyDeclaration").property = t;
}

rule CreateReferencePropertyDefinitionReference
    transform s : ASM!EAnnotation
    to t : OPENAPI!SchemaReference {
        guard: s.eContainer.isKindOf(ASM!EReference) and s.eContainer.containment and s.source == asmUtils.getAnnotationUri("exposedBy")
        
        var targetTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eReferenceType, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
        
		if (s.eContainer.many) {
		    t.ref = targetTypeExposedByAnnotation.equivalent("CreateTransferObjectArraySchemaDeclaration").getReference();
		} else {
		    t.ref = targetTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDeclaration").getReference();
		}
		
        s.equivalent("CreateReferencePropertyDefinition").ref = t;
}

rule CreateDataPropertyDeclarationForCreateAndUpdate
    transform s : ASM!EAnnotation
    to t : OPENAPI!PropertyDeclaration {
        guard: s.eContainer.isKindOf(ASM!EAttribute) and
            s.isForCreateOrUpdate() and
            s.eContainer.changeable and
            not asmUtils.annotatedAsTrue(s.eContainer, "transient")

        t.name = s.eContainer.name;

	    var transferObjectTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
	    transferObjectTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDefinitionForCreateAndUpdate").properties.add(t);
}

rule CreateDataPropertyDefinitionForCreateAndUpdate
    transform s : ASM!EAnnotation
    to t : OPENAPI!Property {
        guard: s.eContainer.isKindOf(ASM!EAttribute) and
            s.isForCreateOrUpdate() and
            s.eContainer.changeable and
            not asmUtils.annotatedAsTrue(s.eContainer, "transient")

        if (s.eContainer.many) {
            throw "Collection attributes are not supported";
        }

        if (s.eContainer.eAttributeType.isKindOf(ASM!EEnum)) {
            t.type = OPENAPI!JSONDataType#string;
            t.enum = s.eContainer.eAttributeType.eLiterals.collect(l | l.name);
        } else {
            switch (s.eContainer.eAttributeType.instanceClassName) {
                case 'java.lang.Boolean': continue;
                case 'boolean':
                    t.type = OPENAPI!JSONDataType#boolean;
                case 'byte[]':
                    t.type = OPENAPI!JSONDataType#string;
                    t.format = "binary";
                case 'java.lang.Double': continue;
                case 'double':
                    t.type = OPENAPI!JSONDataType#number;
                    t.format = "double";
                case 'java.lang.Integer': continue;
                case 'int':
                    t.type = OPENAPI!JSONDataType#integer;
                    t.format = "int32";
                case 'java.lang.Float': continue;
                case 'float':
                    t.type = OPENAPI!JSONDataType#number;
                    t.format = "float";
                case 'java.lang.Long': continue;
                case 'long':
                    t.type = OPENAPI!JSONDataType#integer;
                    t.format = "int64";
                case 'java.lang.String':
                    t.type = OPENAPI!JSONDataType#string;
                    // NOTE - byte format is used for base64 encoded characters, not supported yet
                    // NOTE - password format is not supported yet
                case 'java.math.BigDecimal':
                    t.type = OPENAPI!JSONDataType#number;
                case 'java.math.BigInteger':
                    t.type = OPENAPI!JSONDataType#integer;
                case 'java.time.LocalDate': continue;
                case 'java.util.Date': continue;
                case 'org.joda.time.LocalDate':
                    t.type = OPENAPI!JSONDataType#string;
                    t.format = "date";
                case 'java.time.LocalDateTime': continue;
                case 'java.time.OffsetDateTime': continue;
                case 'java.time.ZonedDateTime': continue;
                case 'org.joda.time.DateTime': continue;
                case 'org.joda.time.LocalDateTime': continue;
                case 'org.joda.time.MutableDateTime':
                    t.type = OPENAPI!JSONDataType#string;
                    t.format = "date-time";
                default:
                    log.info("Unknown attribute type: " + s.eContainer.eAttributeType.instanceClassName);
                    t.type = OPENAPI!JSONDataType#string;
            }
        }

        if (not s.eContainer.changeable) {
            t.readOnly = true;
        } else if (s.eContainer.required) {
            // Read only properties cannot be marked as required by a schema
            var transferObjectTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
            transferObjectTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDefinitionForCreateAndUpdate").required.add(s.eContainer.name);
        }

	    s.equivalent("CreateDataPropertyDeclarationForCreateAndUpdate").property = t;
}

rule CreateReferencePropertyDeclarationForCreateAndUpdate
    transform s : ASM!EAnnotation
    to t : OPENAPI!PropertyDeclaration {
        guard: s.eContainer.isKindOf(ASM!EReference) and
            s.isForCreateOrUpdate() and
            s.eContainer.changeable and
            not asmUtils.annotatedAsTrue(s.eContainer, "transient")

        t.name = s.eContainer.name;
	    var transferObjectTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
	    transferObjectTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDefinitionForCreateAndUpdate").properties.add(t);
}

rule CreateReferencePropertyDefinitionForCreateAndUpdate
    transform s : ASM!EAnnotation
    to t : OPENAPI!Property {
        guard: s.eContainer.isKindOf(ASM!EReference) and
            s.isForCreateOrUpdate() and
            s.eContainer.changeable and
            not asmUtils.annotatedAsTrue(s.eContainer, "transient")

        if (not s.eContainer.changeable) {
            t.readOnly = true;
        } else if (s.eContainer.required) {
            // Read only properties cannot be marked as required by a schema
            var transferObjectTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.get("value") == s.details.get("value"));
            transferObjectTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDefinitionForCreateAndUpdate").required.add(s.eContainer.name);
        }

        if (not s.eContainer.containment and asmUtils.isMappedTransferObjectType(s.eContainer.eReferenceType)) {
            t.type = OPENAPI!JSONDataType#object;
            var entityRef = new OPENAPI!PropertyDeclaration;
            entityRef.name = "__signedIdentifier";
            entityRef.property = new OPENAPI!Property;
            entityRef.property.description = "Signed ID of " + asmUtils.getMappedEntityType(s.eContainer.eReferenceType).get().name + " instance";
            entityRef.property.type = OPENAPI!JSONDataType#string;
            t.properties.add(entityRef);

            var referenceId = new OPENAPI!PropertyDeclaration;
            referenceId.name = "__referenceId";
            referenceId.property = new OPENAPI!Property;
            referenceId.property.description = "Client generated referenceId of " + asmUtils.getMappedEntityType(s.eContainer.eReferenceType).get().name + " instance";
            referenceId.property.type = OPENAPI!JSONDataType#string;
            t.properties.add(referenceId);
        }

        s.equivalent("CreateReferencePropertyDeclarationForCreateAndUpdate").property = t;
}

rule CreateReferencePropertyDefinitionReferenceForCreateAndUpdate
    transform s : ASM!EAnnotation
    to t : OPENAPI!SchemaReference {
        guard: s.eContainer.isKindOf(ASM!EReference) and
            s.eContainer.containment and
            s.isForCreateOrUpdate() and
            s.eContainer.changeable and
            not asmUtils.annotatedAsTrue(s.eContainer, "transient")

        var mappedReference = asmUtils.getMappedReference(s.eContainer).orElse(null);
        if (mappedReference.isDefined() and mappedReference.containment) {
            var targetTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eReferenceType, "exposedBy")
                .selectOne(a | a.details.get("value") == s.details.get("value"));

            if (s.eContainer.many) {
                t.ref = targetTypeExposedByAnnotation.equivalent("CreateTransferObjectArraySchemaDeclarationForCreateAndUpdate").getReference();
            } else {
                t.ref = targetTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDeclarationForCreateAndUpdate").getReference();
            }
        } else {
            var targetFQName = asmUtils.getClassifierFQName(s.eContainer.eReferenceType);
            var optionalTargetType = ASM!EClass.all.selectOne(r | asmUtils.annotatedAsTrue(r, "optional") and asmUtils.getExtensionAnnotationValue(r, "override", false).orElse(null) == targetFQName);

            if (optionalTargetType.isDefined()) {
                var targetTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(optionalTargetType, "exposedBy")
                    .selectOne(a | a.details.get("value") == s.details.get("value"));

                if (s.eContainer.many) {
                    t.ref = targetTypeExposedByAnnotation.equivalent("CreateTransferObjectArraySchemaDeclaration").getReference();
                } else {
                    t.ref = targetTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDeclaration").getReference();
                }
            } else {
                log.error("Optional type is NOT DEFINED for: " + targetFQName);
                var targetTypeExposedByAnnotation = asmUtils.getExtensionAnnotationListByName(s.eContainer.eReferenceType, "exposedBy")
                    .selectOne(a | a.details.get("value") == s.details.get("value"));
                if (s.eContainer.many) {
                    t.ref = targetTypeExposedByAnnotation.equivalent("CreateTransferObjectArraySchemaDeclarationForCreateAndUpdate").getReference();
                } else {
                    t.ref = targetTypeExposedByAnnotation.equivalent("CreateTransferObjectSingleSchemaDeclarationForCreateAndUpdate").getReference();
                }
            }
        }

        s.equivalent("CreateReferencePropertyDefinitionForCreateAndUpdate").ref = t;
}
