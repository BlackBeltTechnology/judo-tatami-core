import "schema.etl";

/*rule CreateDataPropertyDeclaration
    transform s : ASM!EAnnotation
    to t : OPENAPI!PropertyDeclaration {
        guard: s.eContainer.isKindOf(ASM!EAttribute) and s.source == asmUtils.getAnnotationUri("exposedBy")
        
        t.name = s.eContainer.name;
        
        var accessPoint = asmUtils.getResolvedExposedBy(s);
        if (accessPoint.isPresent()) {
		    //accessPoint.get().equivalent("CreateOpenAPIAccessPoint").definitions.add(t);
		    
		    log.info("AP: " + accessPoint.get.equivalent("CreateOpenAPIAccessPoint"));
		    
		    
		    log.info("C: " + s.eContainer.eContainer);
		    
		    var transferObjectType = asmUtils.getExtensionAnnotationListByName(s.eContainer.eContainer, "exposedBy").selectOne(a | a.details.exists(d | d.key == "value" and d.value == s.value));
		    log.info("T: " + transferObjectType);
		    
		    delete t;
        } else {
            delete t;
        }
        
        //log.info("C: " + s.eContainer.eContainingClass);
        //
        //var annotation = asmUtils.getExtensionAnnotation(s.getAnnotatedAttribute().eContainingClass, false);
        //if (annotation.isPresent()) {
	    //    var a = annotation.get().details.selectOne(d | d.key.startsWith(".accessPoints.") and d.value = s.value);
	    //    a.equivalent("CreateTransferObjectSingleSchemaDefinition").properties.add(t);
        //} else {
        //    throw "Container of attribute is not prepared with annotation";
        //}
} */

/*rule CreateDataPropertyDefinition
    transform s : ASM!EStringToStringMapEntry
    to t : OPENAPI!Property {
        guard: s.key.startsWith(".accessPoints.") and s.getAnnotatedAttribute().isDefined()
        
        if (s.getAnnotatedAttribute().many) {
            throw "Collection attributes are not supported";
        }

        switch (s.getAnnotatedAttribute().eAttributeType.instanceClassName) {
            case 'java.lang.Boolean': continue;
            case 'boolean':
                t.type = OPENAPI!JSONDataType#boolean;
            case 'byte[]':
                t.type = OPENAPI!JSONDataType#string;
                t.format = "binary";
            case 'java.lang.Double': continue;
            case 'double':
                t.type = OPENAPI!JSONDataType#number;
                t.format = "double";
            case 'java.lang.Integer': continue;
            case 'int':
                t.type = OPENAPI!JSONDataType#integer;
                t.format = "int32";
            case 'java.lang.Float': continue;
            case 'float':
                t.type = OPENAPI!JSONDataType#number;
                t.format = "float";
            case 'java.lang.Long': continue;
            case 'long':
                t.type = OPENAPI!JSONDataType#integer;
                t.format = "int64";
            case 'java.lang.String':
                t.type = OPENAPI!JSONDataType#string;
                // NOTE - byte format is used for base64 encoded characters, not supported yet
                // NOTE - password format is not supported yet
            case 'java.math.BigDecimal':
                t.type = OPENAPI!JSONDataType#number;
            case 'java.math.BigInteger':
                t.type = OPENAPI!JSONDataType#integer;
            case 'java.time.LocalDate': continue;
            case 'java.util.Date': continue;
            case 'org.joda.time.LocalDate':
                t.type = OPENAPI!JSONDataType#string;
                t.format = "date";
            case 'java.time.LocalDateTime': continue;
            case 'java.time.OffsetDateTime': continue;
            case 'java.time.ZonedDateTime': continue;
            case 'org.joda.time.DateTime': continue;
            case 'org.joda.time.LocalDateTime': continue;
            case 'org.joda.time.MutableDateTime':
                t.type = OPENAPI!JSONDataType#string;
                t.format = "date-time";
            default:
                log.error("Unknown attribute type: " + s.getAnnotatedAttribute().eAttributeType.instanceClassName);
        }

        if (s.getAnnotatedAttribute().required) {
            var annotation = asmUtils.getExtensionAnnotation(s.getAnnotatedAttribute().eContainingClass, false);
	        if (annotation.isPresent()) {
		        var a = annotation.get().details.selectOne(d | d.key.startsWith(".accessPoints.") and d.value = s.value);
		        a.equivalent("CreateTransferObjectSingleSchemaDefinition").required.add(s.getAnnotatedAttribute().name);
	        } else {
	            throw "Container of attribute is not prepared with annotation";
	        }
        }
        
        s.equivalent("CreateDataPropertyDeclaration").property = t;
} */

/*rule CreateReferencePropertyDeclaration
    transform s : ASM!EStringToStringMapEntry
    to t : OPENAPI!PropertyDeclaration {
        guard: s.key.startsWith(".accessPoints.") and s.getAnnotatedReference().isDefined() and s.getAnnotatedReference().containment

        t.name = s.getAnnotatedReference().name;

        var annotation = asmUtils.getExtensionAnnotation(s.getAnnotatedReference().eContainingClass, false);
        if (annotation.isPresent()) {
	        var a = annotation.get().details.selectOne(d | d.key.startsWith(".accessPoints.") and d.value = s.value);
	        a.equivalent("CreateTransferObjectSingleSchemaDefinition").properties.add(t);
        } else {
            throw "Container of attribute is not prepared with annotation";
        }
}

rule CreateReferencePropertyDefinition
    transform s : ASM!EStringToStringMapEntry
    to t : OPENAPI!Property {
        guard: s.key.startsWith(".accessPoints.") and s.getAnnotatedReference().isDefined() and s.getAnnotatedReference().containment

        var annotation = asmUtils.getExtensionAnnotation(s.getAnnotatedReference().eReferenceType, false);
        if (annotation.isPresent()) {
	        var a = annotation.get().details.selectOne(d | d.key.startsWith(".accessPoints.") and d.value = s.value);

            t.ref = new OPENAPI!SchemaReference;
	        if (s.getAnnotatedReference().many) {
	            t.ref.ref = a.equivalent("CreateTransferObjectArraySchemaDeclaration").getReference();
	        } else {
	            t.ref.ref = a.equivalent("CreateTransferObjectSingleSchemaDeclaration").getReference();
	        }

	        if (s.getAnnotatedReference().required) {
	            var containerAnnotation = asmUtils.getExtensionAnnotation(s.getAnnotatedReference().eContainingClass, false);
	            if (containerAnnotation.isPresent()) {
			        var containerA = containerAnnotation.get().details.selectOne(d | d.key.startsWith(".accessPoints.") and d.value = s.value);
                    containerA.equivalent("CreateTransferObjectSingleSchemaDefinition").required.add(s.getAnnotatedReference().name);
			    } else {
			        throw "Container of reference is not prepared with annotation";
			    }
	        }
        } else {
            throw "Target type of reference is not prepared with annotation";
        }

        s.equivalent("CreateReferencePropertyDeclaration").property = t;
}
*/