@cached
operation String normalizeName() : String {
	return self.replace("[__]", "\\$");
}

@cached
operation ASM!EOperation getFullOperationPath() : String {
	return (asmUtils.getPackageFQName(self.eContainingClass.ePackage) + "." + self.name).replaceAll("\\.", "/");
}

@cached
operation ASM!ETypedElement getTypeDefinition() : String {
    var prefix = "";
    var postfix = "";

	if (self.upperBound == -1 or self.upperBound > 1) {
		prefix = "java.util.Collection<";
		postfix = ">";
	}

    var typeName;
	if (self.eType.instanceClass.isDefined()) {
	    typeName = self.eType.instanceClass.name;
	} else if (self.eType.isKindOf(ASM!EEnum)) {
		typeName = "java.lang.Integer";
	} else {
	    throw "Unsupported attribute type: " + self.eType;
	}

	return prefix + typeName + postfix;
}

@cached 
operation getIdTypeName() : String { 
    return "java.util.UUID"; 
}

@cached
operation ASM!EReference getBareTypeDefinition() : String {	
	return self.eReferenceType.getDtoPackageName() + "." + self.eReferenceType.name;
}


@cached
operation ASM!EReference getTypeDefinition() : String {	
	if (self.upperBound == -1 or self.upperBound > 1) {
		return "java.util.Collection<" + self.getBareTypeDefinition() + ">";
	} else {
		return self.getBareTypeDefinition();
	}
}

@cached
operation ASM!EParameter getTypeDefinition() : String {	
	if (self.upperBound == -1 or self.upperBound > 1) {
		return "java.util.Collection<" + self.eType.getDtoTypeName() + ">";
	} else {
		return self.eType.getDtoTypeName();
	}
}


/*
 DTO
 */
@cached
operation getAllDTOs(): Collection {
    return ASM!EClass.all.select(class | 
    	(asmUtils.isMappedTransferObjectType(class) or not asmUtils.isEntityType(class)));
}

@cached
operation getAccessPoints(): Collection {
	return ASM!EClass.all.select(class | asmUtils.isAccessPoint(class));
}

operation genAbstractSdkDao() : String {
	var template = TemplateFactory.load("dao/AbstractSdkDao.java.egl");
	template.populate("package", "sdk.dao");
	var filename = "sdk/dao/AbstractSdkDao.java";
	template.generate(filename);
	return filename;
}

operation genDaoInterfaces(dto : ASM!EClass) : Set {
	var result = new Set();
	if (asmUtils.isMappedTransferObjectType(dto) and /*FIXME - use annotation for skipping *_Reference transferobjects*/ not dto.getName().contains("_") ) {
		var baseName = dto.getDtoDaoPackageName().replaceAll("\\.", "/")+"/"+dto.getClassName();
		
		var template = TemplateFactory.load("dao/Delete.java.egl");
		var filename =  baseName + "Delete.java";
		template.generate(filename);
		result.add(filename);
		
		template = TemplateFactory.load("dao/Create.java.egl");
		filename = baseName + "Create.java";
		template.generate(filename);
		result.add(filename);
		
		template = TemplateFactory.load("dao/GetAll.java.egl");
		filename = baseName + "GetAll.java";
		template.generate(filename);
		result.add(filename);
		
		template = TemplateFactory.load("dao/GetById.java.egl");
		filename = baseName + "GetById.java";
		template.generate(filename);
		result.add(filename);
		
		template = TemplateFactory.load("dao/Update.java.egl");
		filename = baseName + "Update.java";
		template.generate(filename);
		result.add(filename);
		
		for (eReference in dto.getEReferences()) {
			var relatedDto = eReference.getEReferenceType();
			if (asmUtils.isMappedTransferObjectType(relatedDto)) {
				var relationName = eReference.name;
				
				template = TemplateFactory.load("dao/AddRelated.java.egl");
				filename = baseName + "Add" + relationName.firstToUpperCase() + ".java";
				template.generate(filename);
				result.add(filename);
				
				template = TemplateFactory.load("dao/RemoveRelated.java.egl");
				filename = baseName + "Remove" + relationName.firstToUpperCase() + ".java";
				template.generate(filename);
				result.add(filename);
				
				template = TemplateFactory.load("dao/CreateRelated.java.egl");
				filename = baseName + "Create" + relationName.firstToUpperCase() + ".java";
				template.generate(filename);
				result.add(filename);
				
				template = TemplateFactory.load("dao/GetRelated.java.egl");
				filename = baseName + "Get" + relationName.firstToUpperCase() + ".java";
				template.generate(filename);
				result.add(filename);
				
				template = TemplateFactory.load("dao/SetRelated.java.egl");
				filename = baseName + "Set" + relationName.firstToUpperCase() + ".java";
				template.generate(filename);
				result.add(filename);
				
				template = TemplateFactory.load("dao/UnsetRelated.java.egl");
				filename = baseName + "Unset" + relationName.firstToUpperCase() + ".java";
				template.generate(filename);
				result.add(filename);
			}
		}
		
	}
	return result;
}

operation ASM!EClass getDtoDaoPackageName() : String {
	return self.getDtoPackageName()+"."+self.getClassName().toLowerCase() + "dao";
}


operation genDtoInterface(dto : ASM!EClass) {
    var template = TemplateFactory.load("DtoInterface.java.egl");
    template.populate("dto", dto);
    template.generate(dto.getDtoJavaFileName());
    template.reset();
}

operation genDtoBuilder(dto : ASM!EClass) {
    var template = TemplateFactory.load("DtoBuilder.java.egl");
    template.populate("dto", dto);
    template.generate(dto.getDtoBuilderJavaFileName());
    template.reset();
}

operation genOperationInterface(dto : ASM!EClass, op : ASM!EOperation) {
	var map = new Map();
	var t = TemplateFactory.load("Operation.java.egl");
	var inputType;
	if (not op.eParameters.empty) {
		inputType = op.eParameters.get(0).getTypeDefinition();
		map.put("inputType", inputType);
	}
	
	var extendedInterface;
	var extendedMethod;
	var opHasReturn = op.eType.isDefined();
	var opIsBound = asmUtils.isBound(op);
	var opHasParam = inputType.isDefined();
	if (opHasReturn) {
		map.put("ReturnType", op.eType.getDtoTypeName());
	}
	if (opIsBound) {
		map.put("ThisType", dto.getDtoTypeName());
	}
	if (opHasParam) {
		map.put("InputType", inputType);
	}
	if (opHasReturn and opIsBound and opHasParam) {
		extendedInterface = "java.util.function.BiFunction<{ThisType}, {InputType}, {ReturnType}>";
		extendedMethod = "{ReturnType} apply({ThisType} _this, {InputType} input)";
	} else if (opHasReturn and opIsBound and not opHasParam) {
		extendedInterface = "java.util.function.Function<{ThisType}, {ReturnType}>";
		extendedMethod = "{ReturnType} apply({ThisType} _this)";
	} else if (opHasReturn and not opIsBound and opHasParam) {
		extendedInterface = "java.util.function.Function<{InputType}, {ReturnType}>";
		extendedMethod = "{ReturnType} apply({InputType} input)";
	} else if (opHasReturn and not opIsBound and not opHasParam) {
		extendedInterface = "java.util.function.Supplier<{ReturnType}>";
		extendedMethod = "{ReturnType} get()";
	} else if (not opHasReturn and opIsBound and opHasParam) {
		extendedInterface = "java.util.function.BiConsumer<{ThisType}, {InputType}>";
		extendedMethod = "void accept({ThisType} _this, {InputType} input)";
	} else if (not opHasReturn and opIsBound and not opHasParam) {
		extendedInterface = "java.util.function.Consumer<{ThisType}>";
		extendedMethod = "void accept({ThisType} _this)";
	} else if (not opHasReturn and not opIsBound and opHasParam) {
		extendedInterface = "java.util.function.Consumer<{InputType}>";
		extendedMethod = "void accept({InputType} input)";
	} else {
		extendedInterface = "Runnable";
		extendedMethod = "void run()";
	}
	extendedInterface = extendedInterface.replaceAll("\\{ReturnType\\}", map.get("ReturnType"));
	extendedInterface = extendedInterface.replaceAll("\\{InputType\\}", map.get("InputType"));
	extendedInterface = extendedInterface.replaceAll("\\{ThisType\\}", map.get("ThisType"));
	extendedMethod = extendedMethod.replaceAll("\\{ReturnType\\}", map.get("ReturnType"));
	extendedMethod = extendedMethod.replaceAll("\\{InputType\\}", map.get("InputType"));
	extendedMethod = extendedMethod.replaceAll("\\{ThisType\\}", map.get("ThisType"));	
	
	map.put("extendedInterface", extendedInterface);
	map.put("extendedMethod", extendedMethod);
	
    map.put("operation", op);
    map.put("packageName", getOperationJavaPackageName(dto, op));
       
    t.populate("map", map);
    t.generate(getOperationJavaFileName(dto, op));
    
}


operation getOperationJavaPackageName(dto : ASM!EClass, op : ASM!EOperation) {
	return "sdk." + asmUtils.getClassifierFQName(dto).toLowerCase() + "operation";
}

operation getOperationJavaFileName(dto : ASM!EClass, op : ASM!EOperation) {
	var packageName = getOperationJavaPackageName(dto, op);
	return packageName.replaceAll("\\.", "/") + "/" + op.name.firstToUpperCase() + ".java";
}

@cached
operation ASM!EClass idType() : String {
	return "java.util.UUID";
}

@cached
operation ASM!EClass getPackagePrefix() : String {
    return "sdk.";
}

@cached
operation ASM!EClass getDtoPackageName() : String {
	return self.getPackagePrefix() + asmUtils.getPackageFQName(self.ePackage);
}

@cached
operation ASM!EClass getDtoTypeName() : String {
	return self.getDtoPackageName() + "." + self.name;
}

@cached
operation ASM!EClass getDtoJavaFileName() : String {
	return self.getDtoPackageName().replaceAll("\\.", "/") + "/" + self.getClassPackage().toLowerCase().replaceAll("\\.", "/") + "/" + self.getClassName()  + ".java";
}

@cached
operation ASM!EClass getDtoInterfaceJavaFileName() : String {
	return self.getDtoPackageName().replaceAll("\\.", "/") + "/" + self.getClassPackage().toLowerCase().replaceAll("\\.", "/") + "/" + self.getClassName()  + "Interface" + ".java";
}

@cached
operation ASM!EClass getDtoBuilderJavaFileName() : String {
	return self.getDtoPackageName().replaceAll("\\.", "/") + "/" + self.getClassPackage().toLowerCase().replaceAll("\\.", "/") + "/" + self.getClassName()  + "Builder" + ".java";
}

operation ASM!EClass getClassName() : String {
    return self.name;//.split("__")[self.name.split("__").size() - 1];
}

operation ASM!EClass getClassPackage() : String {
    /*var str : String;
    for(s : String in self.name.split("__")) {
       str += "." + s;
    }
    return str.replace("." + self.getClassName(),"");*/
    return ("." + self.name/*.replaceAll("__",".")*/).replace("." + self.getClassName(),"");
}

operation ASM!ENamedElement setterName() : String {
	return "set" + asmUtils.safeName(self.name.firstToUpperCase());
}

operation ASM!ENamedElement getterName() : String {
	return "get" + asmUtils.safeName(self.name.firstToUpperCase());
}

operation ASM!ENamedElement builderName() : String {
	return "with" + asmUtils.safeName(self.name.firstToUpperCase());
}

//Unbound Services
operation genUnboundServiceInterface(ap : ASM!EClass, op : ASM!EOperation) {
	var t = TemplateFactory.load("Service.java.egl");
    t.populate("packagePath", ap.getUnboundServicePackageName());
    t.populate("operation", op.getName());
    t.generate(ap.getUnboundServiceJavaFileName(op.getName()));
    t.reset();
}

operation ASM!EClass getUnboundServicePackageName() : String {
	return "sdk." + asmUtils.getClassifierFQName(self) + "." + self.getUnboundServiceClassName().toLowerCase();
}

operation ASM!EClass getUnboundServiceClassName() : String {
	return "UnboundServices";
}

operation ASM!EClass getUnboundServiceJavaFileName(opname: String) : String {
	return self.getUnboundServicePackageName().replaceAll("\\.", "/") + "/" + opname.firstToUpperCase() + ".java";
}

operation ASM!EClass getUnboundServiceScrXmlFileName() : String {
	return "OSGI-INF/" + self.getUnboundServicePackageName() + "." + self.getUnboundServiceClassName() + ".xml";
}

//Bound Services
operation genExposedMappedTransferObjectInterface(boundOperationClass : ASM!EClass, ap : ASM!EClass, op : ASM!EOperation) {
	var t = TemplateFactory.load("Service.java.egl");
    t.populate("packagePath", boundOperationClass.getExposedMappedTransferObjectPackageName(ap));
    t.populate("operation", op.getName());
    t.generate(boundOperationClass.getExposedMappedTransferObjectJavaFileName(ap,op.getName()));
    t.reset();
}

operation ASM!EClass getExposedMappedTransferObjectPackageName(ap: ASM!EClass) : String {
	return "sdk." + asmUtils.getClassifierFQName(ap) + "." + asmUtils.getPackageFQName(self.ePackage) + "." + self.getExposedMappedTransferObjectClassName().toLowerCase();
}

@cached
operation ASM!EClass getExposedMappedTransferObjectClassName() : String {
	return self.name.replace("__","\\.");
}

operation ASM!EClass getExposedMappedTransferObjectJavaFileName(ap: ASM!EClass, opname: String) : String {
	return self.getExposedMappedTransferObjectPackageName(ap)
		.replaceAll("\\.", "/") + "/" + opname.firstToUpperCase() + ".java";
}

operation ASM!EClass getExposedMappedTransferObjectScrXmlFileName(ap: ASM!EClass) : String {
	return "OSGI-INF/" + self.getExposedMappedTransferObjectPackageName(ap) + "." + self.getExposedMappedTransferObjectClassName() + ".xml";
}
