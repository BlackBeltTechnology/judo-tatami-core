@cached
operation String normalizeName() : String {
	return self.replace("[__]", "\\$");
}

@cached
operation ASM!EOperation getFullOperationPath() : String {
	return (asmUtils.getPackageFQName(self.eContainingClass.ePackage) + "." + self.name).replaceAll("\\.", "/");
}

@cached
operation ASM!ETypedElement getTypeDefinition() : String {
    var prefix = "";
    var postfix = "";

	if (self.upperBound == -1 or self.upperBound > 1) {
		prefix = "java.util.Collection<";
		postfix = ">";
	}

	return prefix + self.getSingleTypeDefinition() + postfix;
}

@cached
operation ASM!ETypedElement getSingleTypeDefinition() : String {
    var typeName;
	if (self.eType.instanceClass.isDefined()) {
	    typeName = self.eType.instanceClass.name;
	} else if (self.eType.isKindOf(ASM!EEnum)) {
		typeName = "java.lang.Integer";
	} else {
	    throw "Unsupported attribute type: " + self.eType;
	}
	return typeName;
}


@cached 
operation getIdTypeName() : String { 
    return "java.util.UUID"; 
}

@cached
operation ASM!EReference getBareTypeDefinition() : String {	
	return self.eReferenceType.getDtoPackageName() + "." + self.eReferenceType.name;
}

@cached
operation ASM!EReference isMulti() : Boolean {
	return self.upperBound == -1 or self.upperBound > 1;
} 

@cached
operation ASM!EReference getTypeDefinition() : String {	
	if (self.upperBound == -1 or self.upperBound > 1) {
		return "java.util.Collection<" + self.getBareTypeDefinition() + ">";
	} else {
		return self.getBareTypeDefinition();
	}
}

@cached
operation ASM!EParameter getTypeDefinition() : String {	
	if (self.upperBound == -1 or self.upperBound > 1) {
		return "java.util.Collection<" + self.eType.getDtoTypeName() + ">";
	} else {
		return self.eType.getDtoTypeName();
	}
}


/*
 DTO
 */
@cached
operation getAllDTOs(): Collection {
    return ASM!EClass.all.select(class | 
    	((asmUtils.isMappedTransferObjectType(class) or not asmUtils.isEntityType(class))) and not asmUtils.annotatedAsTrue(class, "referenceHolder"));
}

operation getAllEntities(): Collection {
    return ASM!EClass.all.select(class | 
    	(asmUtils.isEntityType(class)));
}

@cached
operation getAccessPoints(): Collection {
	return ASM!EClass.all.select(class | asmUtils.isAccessPoint(class));
}

operation genUtil(templateName : String) : String {
	var utilPackageName = getModelPackageName() + ".util";	
	var utilPackagePath = utilPackageName.replaceAll("\\.", "/");

	var template = TemplateFactory.load("util/"+templateName+".java.egl");
	template.populate("package", utilPackageName);
	var fileName = utilPackagePath + "/" + templateName + ".java";
	template.generate(fileName);
	
	return fileName;
}

operation genDaoScrXml(dto : ASM!EClass) {
	var template = TemplateFactory.load("dao/DaoInterface.scr.xml.egl");
	var filename =  "OSGI-INF/" + dto.getDtoDaoPackageName() + "." + dto.getClassName() + "Dao.xml";
	template.generate(filename);
	return filename;
}

operation genDaoInterfaces(dto : ASM!EClass) : Set {
	var result = new Set();
	result.add(genDaoScrXml(dto));	
	var baseName = dto.getDtoDaoPackageName().replaceAll("\\.", "/")+"/"+dto.getClassName();
	var templateName = "dao/Dao.java.egl";
	var daoImpl = false;

	var singleRelations = new Set();
	var multiRelations = new Set();

	for (eReference in dto.getEReferences()) {
		var relatedDto = eReference.getEReferenceType();
		if (asmUtils.isMappedTransferObjectType(relatedDto)) {
			if (eReference.isMulti()) {
				multiRelations.add(eReference);
			} else {
				singleRelations.add(eReference);
			}
		}
	}
	
	var template = TemplateFactory.load(templateName);
	var filename =  baseName + "Dao.java";
	template.generate(filename);
	result.add(filename);	
	var daoImpl = true;
	template = TemplateFactory.load(templateName);
	filename = baseName + "DaoImpl.java";
	template.generate(filename);
	result.add(filename);		
	return result;
}

operation ASM!EClass getDtoDaoPackageName() : String {
	return self.getDtoPackageName()+"."+self.getClassName().toLowerCase() + "dao";
}


operation genDtoInterface(dto : ASM!EClass) {
    var template = TemplateFactory.load("DtoInterface.java.egl");
    template.populate("dto", dto);
    template.generate(dto.getDtoJavaFileName());
    template.reset();
}

operation genDtoBuilder(dto : ASM!EClass) {
    var template = TemplateFactory.load("DtoBuilder.java.egl");
    template.populate("dto", dto);
    template.generate(dto.getDtoBuilderJavaFileName());
    template.reset();
}

operation genOperationScrXmls(dto : ASM!EClass, operations) : Set {
	var generatedFiles = new Set();
	var packageName = getOperationJavaPackageName(dto);	
	
	for (op in operations) {
		if (asmUtils.isEntityType(dto) and asmUtils.isBound(op) or (not asmUtils.isEntityType(dto) and asmUtils.isUnbound(op))) {
			var t = TemplateFactory.load("operation/ExchangeFunction.scr.xml.egl");
			t.populate("packageName", packageName);
			var fileName = getExchangeFunctionScrXmlFileName(dto, op);	
			t.populate("op", op);
			t.generate(fileName);
			generatedFiles.add(fileName);
		}
	}
	
	if (not asmUtils.isEntityType(dto)) {
		var fileName = getDispatcherWrapperScrXmlFileName(dto);	
		var t = TemplateFactory.load("operation/DispatcherWrapper.scr.xml.egl");
		t.populate("packageName", packageName);
		t.generate(fileName);
		generatedFiles.add(fileName);
	}
	
	return generatedFiles;
}

@cached
operation getDispatcherWrapperScrXmlFileName(dto : ASM!EClass) : String {
	return "OSGI-INF/" + getOperationJavaPackageName(dto) + ".wrapper." + dto.getClassName() + "OperationsDispatcherWrapper.xml";
}

@cached
operation getExchangeFunctionScrXmlFileName(dto : ASM!EClass, op : ASM!EOperation) : String {
	return "OSGI-INF/" + getOperationJavaPackageName(dto) + ".exchange." + op.name.firstToUpperCase() + "ExchangeFunction.xml";
}
	

operation genOperationInterfaces(dto : ASM!EClass, operations) : Set {

    var generatedFiles = new Set();

	for (op in operations) {
		// the operation I can implement - only instance for entities or static
	    if ((asmUtils.isEntityType(dto) and asmUtils.isBound(op))
	    or ((not asmUtils.isEntityType(dto)) and asmUtils.isUnbound(op))) {
	    	var map = getOperationGenerationData(dto, op);
		   	var t = TemplateFactory.load("operation/Operation.java.egl");  
		    t.populate("map", map);
		    var fileName = getOperationJavaFileName(map.get("packageName")+".custom", op);
		    t.generate(fileName);
		    generatedFiles.add(fileName);
		    
			// the custom operations called by the dispatcher
			var t = TemplateFactory.load("operation/ExchangeFunction.java.egl");
	    	t.populate("map", map);
	    	var fileName = getExchangeFunctionJavaFileName(map.get("packageName")+".exchange", op);
	    	t.generate(fileName);
	    	generatedFiles.add(fileName);
	    }
	}	
	
    // the operations I can call, one for each transfer entity
    if (not asmUtils.isEntityType(dto)) {
		var t = TemplateFactory.load("operation/DispatcherWrapper.java.egl");	    
	    var fileName = getDispatcherWrapperJavaFileName(getOperationJavaPackageName(dto)+".wrapper", dto);
	    t.generate(fileName);
	    generatedFiles.add(fileName);
	    
		var t = TemplateFactory.load("operation/Operations.java.egl");	    
	    var fileName = getOperationsJavaFileName(getOperationJavaPackageName(dto), dto);
	    t.generate(fileName);
	    generatedFiles.add(fileName);
	}
    
    return generatedFiles;
}

operation getOperationGenerationData(dto : ASM!EClass, op : ASM!EOperation) : Map {
	var map = new Map();
	var opHasParam = not op.eParameters.empty;
	var opHasParamMany = opHasParam and (op.eParameters.get(0).upperBound == -1 or op.eParameters.get(0).upperBound > 1);	
	var extendedInterface;
	var extendedMethod;
	var operationMethod;
	var wrapperImpl;
	var exchangeFunctionImpl;
	var opHasReturn = op.eType.isDefined();
	var opIsBound = asmUtils.isBound(op);
	var opIsMany = op.upperBound == -1 or op.upperBound > 1;
	if (opHasParam) {
		var inputType = op.eParameters.get(0).eType.getDtoTypeName();
		map.put("InputTypeSingle", inputType);
		if (opHasParamMany) {
			inputType = "java.util.Collection<" + inputType + ">";		
		}
		map.put("InputType", inputType);
		map.put("InputName", op.eParameters.get(0).name);
	}	
	if (opHasReturn) {
		var returnTypeName = op.eType.getDtoTypeName();
		map.put("ReturnTypeSingle", returnTypeName);
		if (opIsMany) {
			returnTypeName = "java.util.Collection<"+returnTypeName + ">";
		}
		map.put("ReturnType", returnTypeName);
		map.put("ReturnName", asmUtils.getOutputParameterName(op).get());
	}
	if (opIsBound) {
		if (asmUtils.isEntityType(dto)) {
			var instanceRepresentation = asmUtils.getExtensionAnnotationValue(op, "instanceRepresentation", false).get();
			var instanceRepresentationClass =asmUtils.getClassByFQName(instanceRepresentation).get();
			map.put("ThisType", instanceRepresentationClass.getDtoTypeName());
		} else {
			map.put("ThisType", dto.getDtoTypeName());
		}
	}
	var opReturnTemplate;
	if (opIsMany) { 
		opReturnTemplate =  
			'java.util.Map<String, Object> result = {Call}\n'+
			'        java.util.Collection<java.util.Map<String, Object>> outputPayloads = (java.util.Collection<java.util.Map<String, Object>>) result.get("{ReturnName}");\n' +
			'        return outputPayloads.stream().map(payload -> fromPayload({ReturnTypeSingle}.class, payload)).collect(java.util.stream.Collectors.toList());';
	} else { 
		opReturnTemplate = 
			'java.util.Map<String, Object> result = {Call}\n'+
			'        java.util.Map<String, Object> outputPayload = (java.util.Map<String, Object>) result.get("{ReturnName}");\n' +
			'        return fromPayload({ReturnTypeSingle}.class, outputPayload);';
	}
	var exchangeThis; 
	if (opIsBound) {
		exchangeThis = 'java.util.Map<String, Object> thisPayload = (java.util.Map<String, Object>) exchange.get("__this");\n' +
				'        {ThisType} _this = fromPayload({ThisType}.class, thisPayload);\n';
	}
	var exchangeReturn;
	var exchangeVariable;
	if (opHasReturn) {
		exchangeVariable = '        {ReturnType} result =';
		exchangeReturn = '        return hu.blackbelt.judo.dao.api.Payload.map("{ReturnName}", asMap(result));';
	} else {
		exchangeVariable = "";
		exchangeReturn = '        return hu.blackbelt.judo.dao.api.Payload.empty();';
	}
	var exchangeInput;
	if (opHasParam) {
		if (opHasParamMany) {
			exchangeInput = 'exchange.getAsCollectionPayload("{InputName}").stream().map(payload -> fromPayload({InputTypeSingle}.class, payload)).collect(java.util.stream.Collectors.toList())';
		} else {
			exchangeInput = 'fromPayload({InputTypeSingle}.class, (Map<String, Object>) exchange.get("{InputName}"))';
		}
	} else {
		exchangeInput = "";
	}
	if (opIsBound and opHasParam) {
		var call = 'dispatcher.callOperation(fqName, asMap("__identifier", _this.get__identifier(), "{InputName}", asMap({InputName})));';
		if (not opHasReturn) {
			extendedInterface = "java.util.function.BiConsumer<{ThisType}, {InputType}>";
			extendedMethod = "void accept({ThisType} _this, {InputType} {InputName})";
			operationMethod = "void {OpName}({ThisType} _this, {InputType} {InputName})";
	        wrapperImpl = call;
			exchangeFunctionImpl =
				exchangeThis + 
				'        operation.accept(_this,' + exchangeInput + ');\n' +
				exchangeReturn;	        
        } else {
			extendedInterface = "java.util.function.BiFunction<{ThisType}, {InputType}, {ReturnType}>";
			extendedMethod = "{ReturnType} apply({ThisType} _this, {InputType} {InputName})";
			operationMethod = "{ReturnType} {OpName}({ThisType} _this, {InputType} {InputName})";
			wrapperImpl =  opReturnTemplate.replaceAll("\\{Call\\}", call);
			exchangeFunctionImpl =
				exchangeThis + 
				exchangeVariable + 'operation.apply(_this,' + exchangeInput + ');\n' +
				exchangeReturn;	        			
        }
        		
	} else if (opIsBound and not opHasParam) {
		var call= 'dispatcher.callOperation(fqName, asMap("__identifier", _this.get__identifier()));';
		if (not opHasReturn) {
			extendedInterface = "java.util.function.Consumer<{ThisType}>";
			extendedMethod = "void accept({ThisType} _this)";		
			operationMethod = "void {OpName}({ThisType} _this)";
			wrapperImpl = call;
			exchangeFunctionImpl =
				exchangeThis + 
				'        operation.accept(_this);\n' +
				exchangeReturn;        					
		} else {
			extendedInterface = "java.util.function.Function<{ThisType}, {ReturnType}>";
			extendedMethod = "{ReturnType} apply({ThisType} _this)";
			operationMethod = "{ReturnType} {OpName}({ThisType} _this)";
			wrapperImpl =  opReturnTemplate.replaceAll("\\{Call\\}", call);
			exchangeFunctionImpl =
				exchangeThis + 
				exchangeVariable + 'operation.apply(_this);\n' +
				exchangeReturn;        					
		} 
	
	} else if (not opIsBound and opHasParam) {
		var call = 'dispatcher.callOperation(fqName, asMap("{InputName}", asMap({InputName})));';
		if (not opHasReturn) {
			extendedInterface = "java.util.function.Consumer<{InputType}>";
			extendedMethod = "void accept({InputType} {InputName})";
			operationMethod = "void {OpName}({InputType} {InputName})";
			wrapperImpl =  call;
			exchangeFunctionImpl =
				exchangeThis + 
				exchangeVariable + 'operation.accept(' + exchangeInput + ');\n' +
				exchangeReturn;        					
		} else {
			extendedInterface = "java.util.function.Function<{InputType}, {ReturnType}>";
			extendedMethod = "{ReturnType} apply({InputType} {InputName})";
			operationMethod = "{ReturnType} {OpName}({InputType} {InputName})";
			wrapperImpl =  opReturnTemplate.replaceAll("\\{Call\\}", call);
			exchangeFunctionImpl = 			
				exchangeThis + 
				exchangeVariable + 'operation.apply(' + exchangeInput + ');\n' +
				exchangeReturn;        								
		}
	} else if (not opIsBound and not opHasParam) { 
		var call = 'dispatcher.callOperation(fqName, hu.blackbelt.judo.dao.api.Payload.empty());';
		if (not opHasReturn) {
			extendedInterface = "Runnable";
			extendedMethod = "void run()";
			operationMethod = "void {OpName}()";
			wrapperImpl =  call;
			exchangeFunctionImpl = 'operation.run();' +
				exchangeReturn;        					
		} else {
			extendedInterface = "java.util.function.Supplier<{ReturnType}>";
			extendedMethod = "{ReturnType} get()";
			operationMethod = "{ReturnType} {OpName}()";
			wrapperImpl =  opReturnTemplate.replaceAll("\\{Call\\}", call);
			exchangeFunctionImpl = 
				exchangeVariable + 'operation.get();\n' +
				exchangeReturn;        					
		}
	}

    map.put("operation", op);
    map.put("packageName", getOperationJavaPackageName(dto));
     
	map.put("extendedInterface", extendedInterface.replacePlaceholders(map));
	map.put("extendedMethod", extendedMethod.replacePlaceholders(map));
	map.put("wrapperImpl", wrapperImpl.replacePlaceholders(map));
	map.put("exchangeFunctionImpl", exchangeFunctionImpl.replacePlaceholders(map));
	map.put("operationMethod", operationMethod.replacePlaceholders(map));
	

 	return map;
}

operation String replacePlaceholders(map) : String {
	var result = self;
	result = result.replaceAll("\\{InputName\\}", map.get("InputName"));	
	result = result.replaceAll("\\{ReturnType\\}", map.get("ReturnType"));
	result = result.replaceAll("\\{ReturnTypeSingle\\}", map.get("ReturnTypeSingle"));
	result = result.replaceAll("\\{ReturnName\\}", map.get("ReturnName"));
	result = result.replaceAll("\\{ThisType\\}", map.get("ThisType"));
	result = result.replaceAll("\\{InputType\\}", map.get("InputType"));
	result = result.replaceAll("\\{InputTypeSingle\\}", map.get("InputTypeSingle"));
	result = result.replaceAll("\\{OpName\\}", map.get("operation").name);	
	return result;
}


operation getOperationJavaPackageName(dto : ASM!EClass) {
	return getPackagePrefix() + asmUtils.getClassifierFQName(dto).toLowerCase() + "operation";
}

operation getOperationJavaFileName(packageName : String, op : ASM!EOperation) {
	return packageName.replaceAll("\\.", "/") + "/" + op.name.firstToUpperCase() + ".java";
}

operation getOperationsJavaFileName(packageName : String, dto : ASM!EClass) {	
	return packageName.replaceAll("\\.", "/") + "/" + dto.getClassName() + "Operations.java";
}
operation getDispatcherWrapperJavaFileName(packageName : String, dto : ASM!EClass) {	
	return packageName.replaceAll("\\.", "/") + "/" + dto.getClassName() + "OperationsDispatcherWrapper.java";
}

operation getExchangeFunctionJavaFileName(packageName : String, op : ASM!EOperation) {	
	return packageName.replaceAll("\\.", "/") + "/" + op.name.firstToUpperCase() + "ExchangeFunction.java";
}


@cached
operation ASM!EClass idType() : String {
	return "java.util.UUID";
}

@cached
operation getPackagePrefix() : String {
    return "sdk.";
}

@cached
operation getModelPackageName() : String {
	return (getPackagePrefix() + asmUtils.getPackageFQName(asmUtils.getModel().get())).toLowerCase(); 
}

@cached
operation ASM!EClass getDtoPackageName() : String {
	return (getPackagePrefix() + asmUtils.getPackageFQName(self.ePackage)).toLowerCase();
}

@cached
operation ASM!EClass getDtoTypeName() : String {
	return self.getDtoPackageName() + "." + self.name;
}

@cached
operation ASM!EClass getDtoJavaFileName() : String {
	return self.getDtoPackageName().replaceAll("\\.", "/") + "/" + self.getClassName()  + ".java";
}

@cached
operation ASM!EClass getDtoInterfaceJavaFileName() : String {
	return self.getDtoPackageName().replaceAll("\\.", "/") + "/" + self.getClassName()  + "Interface" + ".java";
}

@cached
operation ASM!EClass getDtoBuilderJavaFileName() : String {
	return self.getDtoPackageName().replaceAll("\\.", "/") + "/" + self.getClassName()  + "Builder" + ".java";
}

operation ASM!EClass getClassName() : String {
    return self.name;
}

operation ASM!ENamedElement setterName() : String {
	return "set" + asmUtils.safeName(self.name.firstToUpperCase());
}

operation ASM!ENamedElement getterName() : String {
	return "get" + asmUtils.safeName(self.name.firstToUpperCase());
}

operation ASM!ENamedElement builderName() : String {
	return "with" + asmUtils.safeName(self.name.firstToUpperCase());
}