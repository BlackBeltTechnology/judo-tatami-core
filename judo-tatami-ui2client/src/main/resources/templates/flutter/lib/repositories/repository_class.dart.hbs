//////////////////////////////////////////////////////////////////////////////
// G E N E R A T E D    C L A S S
// ------------------------------
// Factory expression: {{{ cleanup template.factoryExpression }}}
// Path expression: {{{ cleanup template.pathExpression }}}
// Overwrite: {{{ cleanup template.overwriteExpression }}}
// Template name: {{ template.templateName }}
// Application: {{ application.name }}
//
//   Class: {{ class.name }} behaviours: {{# each class.behaviours }} {{{ . }}} {{/ each }}

part of {{ variable ap.name }}.repository;

class {{ fqClass class.name }}Repository {

  //////////////////////////////////////////////////////////////////////////////
  // TEMPLATE (Default)
  //////////////////////////////////////////////////////////////////////////////
  Future<{{ fqClass class.name }}Store> {{ fqVariable class.name }}Default() async {
    // TODO: NOT SUPPORTED YET
    // {{ fqClass class.name }} {{ variable class.name }}Response = await DefaultApi(locator<ApiClient>()).{{ fqVariable class.name }}TemplateInstance{{ fqClass name }}();
    // return {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass class.name }}StoreFrom{{ fqClass class.name }}({{ variable class.name }}Response);
    return {{ fqClass class.name }}Store();
  }
  {{# if class.isMapped }}

  //////////////////////////////////////////////////////////////////////////////
  // REFRESH (Reload with Signed ID)
  //////////////////////////////////////////////////////////////////////////////
  Future<{{ fqClass class.name }}Store> {{ fqVariable class.name }}GetByIdentifier({{ fqClass class.name }}Store target) async {
    {{ fqClass class.transferObjectTypeName }} {{ variable class.name }}Response = await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}RefreshInstance{{ fqClass name }}(target.internal__signedIdentifier);
    return {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass class.name }}StoreFrom{{ fqClass class.name }}({{ variable class.name }}Response);
  }
  {{/ if }}
  {{# if class.isClassBehaviourTypeUpdateValidatable }}

  //////////////////////////////////////////////////////////////////////////////
  // VALIDATE UPDATE
  //////////////////////////////////////////////////////////////////////////////
  Future<{{ fqClass class.name }}Store> {{ fqVariable class.name }}ValidateForUpdate({{ fqClass class.name }}Store target) async {
    {{ fqClass class.transferObjectTypeName }}ForCreateAndUpdate {{ variable class.name }}Request = {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass class.name }}ForCreateAndUpdateFrom{{ fqClass class.name }}Store(target);
    {{ fqClass class.transferObjectTypeName }} {{ variable class.name }}Response = await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}ValidateUpdateInstance{{ fqClass name }}(target.internal__signedIdentifier, {{ variable class.name }}Request);
    return {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass class.name }}StoreFrom{{ fqClass class.name }}({{ variable class.name }}Response);
  }
  {{/ if }}
  {{# if class.isClassBehaviourTypeDeletable }}

  //////////////////////////////////////////////////////////////////////////////
  // DELETE
  //////////////////////////////////////////////////////////////////////////////
  Future<void> {{ fqVariable class.name }}Delete({{ fqClass class.name }}Store target) async {
    return await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}DeleteInstance{{ fqClass name }}(target.internal__signedIdentifier);
  }
  {{/ if }}
  {{# if class.isClassBehaviourTypeUpdatable }}

  //////////////////////////////////////////////////////////////////////////////
  // UPDATE
  //////////////////////////////////////////////////////////////////////////////
  Future<{{ fqClass class.name }}Store> {{ fqVariable class.name }}Update({{ fqClass class.name }}Store target) async {
    {{ fqClass class.transferObjectTypeName }}ForCreateAndUpdate {{ variable class.name }}Request = {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass class.name }}ForCreateAndUpdateFrom{{ fqClass class.name }}Store(target);
    {{ fqClass class.transferObjectTypeName }} {{ variable class.name }}Response = await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}UpdateInstance{{ fqClass name }}(target.internal__signedIdentifier, {{ variable class.name }}Request);
    return {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass class.name }}StoreFrom{{ fqClass class.name }}({{ variable class.name }}Response);
  }
  {{/ if }}
  {{# each class.relations as |relation| }}
      {{# if relation.isRelationBehaviourTypeRangeable }}

  //////////////////////////////////////////////////////////////////////////////
  // GET CREATE RANGE FOR {{ variable relation.name }}
  //////////////////////////////////////////////////////////////////////////////
  Future<List<{{ fqClass relation.target.name }}Store>> {{ fqVariable class.name }}RangeOf{{ fqClass relation.name }}ToCreate({{ fqClass class.name }}Store target) async {
    // Use this when JNG-2028 is done
    // {{modelName ap.name}}Extension{{packageName class.name}}GetRangeInput{{className class.name}} {{ variable class.name }}Request = {{ fqClass ap.name }}RepositoryStoreMapper.create{{modelName ap.name}}Extension{{packageName class.name}}GetRangeInput{{className class.name}}From{{ fqClass class.name }}Store(target);
    var {{ variable class.name }}Request = {{modelName ap.name}}Extension{{packageName class.name}}GetRangeInput{{className class.name}}{{ className relation.name }}();
    List<{{ fqClass relation.target.transferObjectTypeName }}> {{ variable relation.target.name }}ListResponse = await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}GetRangeReference{{ fqClass relation.name }}(input: {{ variable class.name }}Request);
    return {{ variable relation.target.name }}ListResponse.map<{{ fqClass relation.target.name }}Store>(
      {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass relation.target.name }}StoreFrom{{ fqClass relation.target.name }}).toList();
  }

  //////////////////////////////////////////////////////////////////////////////
  // GET UPDATE RANGE FOR {{ variable relation.name }}
  //////////////////////////////////////////////////////////////////////////////
  Future<List<{{ fqClass relation.target.name }}Store>> {{ fqVariable class.name }}RangeOf{{ fqClass relation.name }}ToUpdate({{ fqClass class.name }}Store target) async {
    // Use this when JNG-2028 is done
    // {{modelName ap.name}}Extension{{packageName class.name}}GetRangeInput{{className class.name}} {{ variable class.name }}Request = {{ fqClass ap.name }}RepositoryStoreMapper.create{{modelName ap.name}}Extension{{packageName class.name}}GetRangeInput{{className class.name}}From{{ fqClass class.name }}Store(target);
    var {{ variable class.name }}Request = {{modelName ap.name}}Extension{{packageName class.name}}GetRangeInput{{className class.name}}{{ className relation.name }}();
    List<{{ fqClass relation.target.transferObjectTypeName }}> {{ variable relation.target.name }}ListResponse = await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}GetRangeReference{{ fqClass relation.name }}(input: {{ variable class.name }}Request);
    return {{ variable relation.target.name }}ListResponse.map<{{ fqClass relation.target.name }}Store>(
      {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass relation.target.name }}StoreFrom{{ fqClass relation.target.name }}).toList();
  }
      {{/ if }}
      {{# if relation.isRelationBehaviourTypeSetable }}
        {{# if relation.isCollection }}

  //////////////////////////////////////////////////////////////////////////////
  // SET {{ variable relation.name }} (Collection)
  //////////////////////////////////////////////////////////////////////////////
  Future<void> {{ fqVariable class.name }}Set{{ fqClass relation.name }}({{ fqClass class.name }}Store target, List<{{ fqClass relation.target.name }}Store> selected) async {
    List<dynamic> itemsToSet = selected.map<dynamic>((s) => {"__signedIdentifier": s.internal__signedIdentifier}).toList();
    return await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}SetReference{{ className relation.name }}(target.internal__signedIdentifier, input: itemsToSet);
  }
        {{ else }}

  //////////////////////////////////////////////////////////////////////////////
  // SET {{ variable relation.name }} (Single)
  //////////////////////////////////////////////////////////////////////////////
  Future<void> {{ fqVariable class.name }}Set{{ fqClass relation.name }}({{ fqClass class.name }}Store target, {{ fqClass relation.target.name }}Store selected) async {
    return await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}SetReference{{ className relation.name }}(target.internal__signedIdentifier, SingleReference().copyWith(internal__signedIdentifier: selected.internal__signedIdentifier));
  }
        {{/ if }}
      {{/ if }}
      {{# if relation.isRelationBehaviourTypeUnsetable }}

  //////////////////////////////////////////////////////////////////////////////
  // UNSET {{ variable relation.name }}
  //////////////////////////////////////////////////////////////////////////////
  Future<void> {{ fqVariable class.name }}Unset{{ fqClass relation.name }}({{ fqClass class.name }}Store target) async {
    return await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}UnsetReference{{ className relation.name }}(target.internal__signedIdentifier);
  }
      {{/ if }}
      {{# if relation.isRelationBehaviourTypeAddable }}

  //////////////////////////////////////////////////////////////////////////////
  // ADD {{ variable relation.name }}
  //////////////////////////////////////////////////////////////////////////////
  Future<void> {{ fqVariable class.name }}Add{{ fqClass relation.name }}({{ fqClass class.name }}Store target, List<{{ fqClass relation.target.name }}Store> selected) async {
    List<dynamic> itemsToAdd = selected.map<dynamic>((s) => {"__signedIdentifier": s.internal__signedIdentifier}).toList();
    return await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}AddReference{{ className relation.name }}(target.internal__signedIdentifier, itemsToAdd);
  }
      {{/ if }}
      {{# if relation.isRelationBehaviourTypeRemovable }}

  //////////////////////////////////////////////////////////////////////////////
  // REMOVE {{ variable relation.name }}
  //////////////////////////////////////////////////////////////////////////////
  Future<void> {{ fqVariable class.name }}Remove{{ fqClass relation.name }}({{ fqClass class.name }}Store target, List<{{ fqClass relation.target.name }}Store> selected) async {
    List<dynamic> itemsToRemove = selected.map<dynamic>((s) => {"__signedIdentifier": s.internal__signedIdentifier}).toList();
    return await DefaultApi(locator<ApiClient>()).{{ fqVariable class.transferObjectTypeName }}RemoveReference{{ className relation.name }}(target.internal__signedIdentifier, itemsToRemove);
  }
      {{/ if }}
  {{/ each }}

  {{# each class.operations as |operation|}}
  //////////////////////////////////////////////////////////////////////////////
  // OPERATION {{ variable operation.name }}
  //////////////////////////////////////////////////////////////////////////////
      {{# if operation.output}}Future<{{# if operation.output.isCollection }}List<{{fqClass operation.output.target.name}}Store>{{ else }}{{fqClass operation.output.target.name}}Store{{/if}}>{{else}}Future<void>{{/if}} {{fqVariable operation.owner.name}}{{className operation.name}}({{#if operation.input}}{{fqClass operation.input.target.name}}Store {{fqVariable operation.input.target.name}}Store, {{/if}}{{#if operation.isMapped }}{{ fqClass class.name }}Store {{ fqVariable class.name }}Store{{/if}}) async {
      {{#if operation.input}}{{fqClass operation.input.target.transferObjectTypeName}} {{fqVariable operation.input.target.name}}Input = {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass operation.input.target.name }}From{{ fqClass operation.input.target.name }}Store({{fqVariable operation.input.target.name}}Store);{{/if}}
      {{#if operation.output}}
          {{# if operation.output.isCollection }}
      List<{{fqClass operation.output.target.transferObjectTypeName}}> {{fqVariable operation.output.target.name}}Output = await DefaultApi(locator<ApiClient>()).{{fqVariable operation.owner.transferObjectTypeName}}{{className operation.name}}({{#if operation.isMapped }}{{ fqVariable class.name }}Store.internal__signedIdentifier, {{/if}}{{#if operation.input}}{{# if operation.input.isOptional}}input: {{/ if }}{{#if operation.input.isCollection}}[{{fqVariable operation.input.target.name}}Input]{{else}}{{fqVariable operation.input.target.name}}Input{{/if}}{{/if}});
      return {{fqVariable operation.output.target.name}}Output.map<{{fqClass operation.output.target.name}}Store>((e) => {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass operation.output.target.name }}StoreFrom{{ fqClass operation.output.target.name }}(e)).toList();
          {{ else }}
      {{fqClass operation.output.target.transferObjectTypeName}} {{fqVariable operation.output.target.name}}Output = await DefaultApi(locator<ApiClient>()).{{fqVariable operation.owner.transferObjectTypeName}}{{className operation.name}}({{#if operation.isMapped }}{{ fqVariable class.name }}Store.internal__signedIdentifier, {{/if}}{{#if operation.input}}{{# if operation.input.isOptional}}input: {{/ if }}{{#if operation.input.isCollection}}[{{fqVariable operation.input.target.name}}Input]{{else}}{{fqVariable operation.input.target.name}}Input{{/if}}{{/if}});
      return {{ fqClass ap.name }}RepositoryStoreMapper.create{{ fqClass operation.output.target.name }}StoreFrom{{ fqClass operation.output.target.name }}({{fqVariable operation.output.target.name}}Output);
          {{/if}}
      {{else}}
      return await DefaultApi(locator<ApiClient>()).{{fqVariable operation.owner.transferObjectTypeName}}{{className operation.name}}({{#if operation.isMapped }}{{ fqVariable class.name }}Store.internal__signedIdentifier, {{/if}}{{#if operation.input}}{{# if operation.input.isOptional}}input: {{/ if }}{{fqVariable operation.input.target.name}}Input{{/if}});
      {{/if}}
  }

  {{/each}}
}
