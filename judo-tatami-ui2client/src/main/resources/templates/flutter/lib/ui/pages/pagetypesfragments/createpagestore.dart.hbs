class {{ fqClass page.name }}PageStore extends _{{ fqClass page.name }}PageStore with _${{ fqClass page.name }}PageStore {}

abstract class _{{ fqClass page.name }}PageStore with Store {
    {{# with page.relationType as |relation| }}
    {{ fqClass application.actor.name }}Repository _{{ fqVariable application.actor.name }}Repository = locator<{{ fqClass application.actor.name }}Repository>();

    @observable
    String errorMessage;

    @observable
    ObservableFuture {{ fqVariable relation.name }}StoreFuture;

    @action
    Future<{{ fqClass relation.target.name }}Store> validate{{ fqClass relation.name }}({{# unless page.dataElement.isAccess}}{{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store, {{/unless}}{{ fqClass relation.target.name }}Store target{{ className relation.target.name }}Store) async {
        try {
            errorMessage = null;
            return await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}ValidateForCreate({{# unless page.dataElement.isAccess}}owner{{ className relation.owner.name }}Store, {{/unless}}target{{ className relation.target.name }}Store);
        } on ApiException {
            errorMessage = "Could not validate {{ relation.name }}";
        }
    }

    {{/ with }}
    {{# each page.dataElement.target.relations as |relation| }}
    {{# if isRelationKindAggregation }}
        {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/aggregationactions.dart.hbs page=page relation=relation}}
    {{/ if}}
    {{# if isRelationKindComposition }}
        {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/compositionactions.dart.hbs page=page relation=relation}}
    {{/ if}}
    {{/ each}}
}
