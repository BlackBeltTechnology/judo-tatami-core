{{# with dataElement as |relation|}}
Flexible(
    fit: FlexFit.loose,
    flex: 12,
    child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
            Flexible(
                fit: FlexFit.loose,
                flex: 12,
                child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                    {{# each table.relationActions as |relationAction| }}
                        JudoButton(
                            col: {{col}},
                            disabled: {{disabled}},
                        {{# if relationAction.isBackAction }}
                            onPressed: () => navigation.close(),
                        {{/ if }}
                        {{# if relationAction.isCreateAction }}
                            onPressed:{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}{{/ unless}} () async {
                                var created = await navigation.open(Routes.{{ fqVariable relationAction.target.name }}Page{{# unless relation.isAccess}},
                                arguments: {{ fqClass relationAction.target.name }}PageArguments(owner{{ className relation.owner.name }}Store: target{{ className relation.owner.name }}Store){{~/ unless}});
                                if (created != null) {
                                    {{ fqVariable page.name }}PageStore.create{{ fqClass relation.name }}({{# unless relation.isAccess}}target{{ className relation.owner.name }}Store ,{{/ unless}}created);
                                }
                            }{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} : null{{/ unless}}{{/ unless}},
                        {{/ if }}
                        {{#if relationAction.isAddAction}}
                            onPressed:{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}{{/ unless}} () async {
                                var selected =
                                    {{> templates/flutter/lib/ui/pages/widgets/dialog.dart.hbs relation=relation}}
                                if (selected != null) {
                                    {{fqVariable page.name}}PageStore.add{{ fqClass relation.name }}(target{{ className relation.owner.name }}Store, selected);
                                }
                            }{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} : null{{/ unless}}{{/ unless}},
                        {{/if}}
                        {{#if relationAction.isSetAction}}
                            onPressed:{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}{{/ unless}} () async {
                                var selected =
                                    {{> templates/flutter/lib/ui/pages/widgets/dialog.dart.hbs relation=relation}}
                                if (selected != null) {
                                    {{fqVariable page.name}}PageStore.set{{ fqClass relation.name }}(target{{ className relation.owner.name }}Store, selected);
                                }
                            }{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} : null{{/ unless}}{{/ unless}},
                        {{/if}}
                        {{# if relationAction.isNavigationToPageAction }}
                            onPressed: () async {
                                await navigation.open(Routes.{{ fqVariable relationAction.target.name }}Page,
                                arguments: {{ fqClass relationAction.target.name }}PageArguments(owner{{ className relationAction.target.dataElement.owner.name }}Store: target{{ className relationAction.target.dataElement.owner.name }}Store));
                            },
                        {{/ if }}
                        {{#if label }}
                            label: '{{label}}',
                        {{/if}}
                        {{#if icon }}
                            icon: Icon(Icons.{{icon.name}}),
                        {{/if}}
                            rounded: true,
                        ),
                    {{/ each }}
                    ]
                ),
            ),
            Flexible(
                fit: FlexFit.loose,
                flex: 12,
                child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                        Observer(builder: (_) {
                            return JudoTable(
                                disabled: {{disabled}},
                                col: {{col}},
                                dataInfo: {{ fqClass pageDefinition.name }}{{ fqClass table.name }}{{ fqClass pageContainer.layoutType.name }}Table(disabled: {{disabled}}),
                                rowList: {{# if relation.isCollection }}target{{ className relation.owner.name }}Store.{{variable relation.name}}{{else}}[target{{ className relation.owner.name }}Store.{{variable relation.name}}].asObservable(){{/ if}},
                                {{#each table.rowActions as |relationAction|}}
                                {{#if relationAction.isViewAction}}
                                navigateToViewPageAction: (element) async {
                                    var response = await navigation.open(Routes.{{ fqVariable relationAction.target.name }}Page,
                                    arguments: {{ fqClass relationAction.target.name }}PageArguments({{# unless relation.isAccess}}owner{{ className relation.owner.name }}Store: target{{ className relation.owner.name }}Store, {{/ unless}}target{{ className relation.target.name }}Store: element));
                                    if (response != null) {
                                        {{ fqVariable page.name }}PageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess}}target{{ className relation.owner.name }}Store{{/ unless}});
                                    }
                                },
                                {{/if}}
                                {{#if relationAction.isCreateAction}}
                                // TODO: not sure this rowAction needed
                                navigateToCreatePageAction:{{# unless relation.isAccess}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}e (element) async {
                                    var created = await navigation.open(Routes.{{ fqVariable relationAction.target.name }}Page);
                                    if (created != null) {
                                        {{ fqVariable page.name }}PageStore.create{{ fqClass relation.name }}({{# unless relation.isAccess}}target{{ className relation.owner.name }}Store ,{{/ unless}}created);
                                    }
                                }{{# unless relation.isAccess}} : null{{/ unless}},
                                {{/if}}
                                {{#if relationAction.isEditAction}}
                                navigateToEditPageAction: (element) async {
                                    {{ fqClass relationType.target.name }}Store cloned = {{ fqClass relationType.target.name }}Store();
                                    cloned.updateWith(element);
                                    var res = await navigation.open(Routes.{{ fqVariable relationAction.target.name }}Page,
                                    arguments: {{ fqClass relationAction.target.name }}PageArguments(target{{ className relation.target.name }}Store: cloned));
                                    if (res != null) {
                                        element.updateWith(cloned);
                                        var updated = await {{ fqVariable page.name }}PageStore.update{{ className relation.target.name }}(element);
                                        if (updated != null) {
                                            element.updateWith(updated);
                                            {{ fqVariable page.name }}PageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess}}target{{ className relation.owner.name }}Store{{/ unless}});
                                        }
                                    }
                                },
                                {{/if}}
                                {{#if relationAction.isRemoveAction}}
                                removeAction:{{# unless page.dataElement.isAccess}} owner{{ className page.dataElement.owner.name }}Store.internal__updatable ?{{/ unless}} (element) => {{fqVariable page.name}}PageStore.remove{{ fqClass relation.name }}(target{{ className relation.owner.name }}Store, element){{# unless relation.isAccess}} : null{{/ unless}},
                                {{/if}}
                                {{#if relationAction.isUnsetAction}}
                                unsetAction:{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}{{/ unless}} () async {
                                    {{fqVariable page.name}}PageStore.unset{{ fqClass relation.name }}(target{{ className relation.owner.name }}Store);
                                }{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} : null{{/ unless}}{{/ unless}},
                                {{/if}}
                                {{#if relationAction.isDeleteAction}}
                                deleteAction:{{# unless relation.isAccess}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}} (element) async {
                                    {{fqVariable page.name}}PageStore.delete{{ className relation.target.name }}(element{{# unless relation.isAccess}}, owner{{ className relation.owner.name }}Store{{/unless}});
                                }{{# unless relation.isAccess}} : null{{/ unless}},
                                {{/if}}
                                {{/each}}
                            );
                        }),
                    ]
                ),
            ),
        ]
    ),
),
{{/ with}}