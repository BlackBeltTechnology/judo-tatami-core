{{ log 'Pagestore generation for' (variable application.name) '-' (fqClass page.name) level='debug' }}
//START operationoutputpagestore.dart.hbs-----{{ page.name }}--------------------------------------------------------------------------------
class {{ fqClass page.name }}PageStore extends _{{ fqClass page.name }}PageStore with _${{ fqClass page.name }}PageStore {}

abstract class _{{ fqClass page.name }}PageStore with Store {
{{# with page.dataElement as |data| }}
    {{ fqClass application.actor.name }}Repository _{{ fqVariable application.actor.name }}Repository = locator<{{ fqClass application.actor.name }}Repository>();

    @observable
    String errorMessage;

    @observable
    ObservableFuture {{ fqVariable data.name }}StoreFuture;

    // TODO: review that this is necessary in all cases
    bool validatable = false;

    {{# if data.isRelationBehaviourTypeRefreshable }}
    @action
    Future<void> refresh{{ className data.target.name }}({{ storeClassName data.target.name }} targetStore) async {
        try {
            errorMessage = null;
            targetStore.updateWith(await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable data.target.name }}GetByIdentifier(targetStore));
        } on ApiException catch (error) {
            errorMessage = "Could not refresh {{ variable data.target.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if data.isRelationBehaviourTypeUpdatable }}
    @action
    Future<{{ storeClassName data.target.name }}> update{{ className data.target.name }}({{ storeClassName data.target.name }} targetStore) async {
        try {
            errorMessage = null;
            return await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable data.target.name }}Update(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not update {{ variable data.target.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if data.isRelationBehaviourTypeDeletable }}
    @action
    Future<void> delete{{ className data.target.name }}({{ storeClassName data.target.name }} targetStore) async {
        try {
            errorMessage = null;
            await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable data.target.name }}Delete(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not delete {{ variable data.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if data.isRelationBehaviourTypeCreateValidatable }}
    @action
    Future<{{ storeClassName data.target.name }}> validate({{# unless page.dataElement.isAccess }}{{ storeClassName data.owner.name }} ownerStore, {{/ unless }}{{ storeClassName data.target.name }} targetStore) async {
        try {
            errorMessage = null;
            return await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable data.owner.name }}{{ fqClass data.name }}ValidateForCreate({{# unless page.dataElement.isAccess }}ownerStore, {{/ unless }}targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not validate {{ data.name }}";
            throw error;
        }
    }

    {{/ if }}
{{/ with }}
{{# each page.dataElement.target.relations as |relation| }}
    {{# unless isMemberTypeTransient }}
        {{# if isRelationKindAggregation }}
    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/aggregationactions.dart.hbs page=page relation=relation }}
        {{/ if }}
        {{# if isRelationKindComposition }}
    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/aggregationactions.dart.hbs page=page relation=relation }}
        {{/ if }}
    {{/ unless }}
{{/ each }}

    //OPERATIONS
    {{# each page.dataElement.target.operations as |operation| }}
    @action
    {{# if operation.output }}Future<{{# if operation.output.isCollection }}List<{{ storeClassName operation.output.target.name }}>{{ else }}{{ storeClassName operation.output.target.name }}{{/ if }}>{{ else }}Future<void>{{/ if }} {{ fqVariable operation.owner.name }}{{ className operation.name }}({{# if operation.input }}{{ storeClassName operation.input.target.name }} targetStore, {{/ if }}{{# if operation.isMapped }}{{ storeClassName operation.owner.name }} ownerStore{{/ if }}) async {
        try {
            errorMessage = null;
            {{# if operation.output }}return {{/ if }}await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable operation.owner.name }}{{ className operation.name }}({{# if operation.input }}targetStore, {{/ if }}{{# if operation.isMapped }}ownerStore{{/ if }});
        } on ApiException {
            errorMessage = "Could not call operation {{ operation.name }}";
        }
    }
    {{/ each }}
}
//END operationoutputpagestore.dart.hbs-----{{ page.name }}----------------------------------------------------------------------------------
