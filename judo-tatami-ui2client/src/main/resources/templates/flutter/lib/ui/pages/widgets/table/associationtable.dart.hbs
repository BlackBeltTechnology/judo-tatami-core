{{ log 'Table generation for' (variable application.name) '-' (fqClass page.name) (variable dataElement.name) level='debug' ~}}
//START associationtable.dart.hbs-----{{ dataElement.name }}---------------------------------------------------------------------------------
{{# with page.dataElement as |relation| }}
Observer(
    builder: (_) => JudoColumn(
        col: 1,
        row: pageStore.getPlusRowSize as double,
        children: getInputFilterWidgetsForTablePage(context, pageStore.availableFilterList, {{ table.col }}, () => pageStore.get{{ className relation.name }}({{# unless relation.isAccess }}ownerStore{{/ unless }}).catchError((error) => ErrorHandler.showErrorSnack(context, error.message))),
    ),
),
// ignore: missing_return
Observer(builder: (_) {
    switch(pageStore.{{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture.status){
        case FutureStatus.pending:
            return JudoLoadingProgress();
        case FutureStatus.rejected:
            return Container();
        case FutureStatus.fulfilled:
            var dataInfo = {{ fqClass pageDefinition.name }}{{ fqClass table.name }}{{ fqClass pageContainer.layoutType.name }}Table(context, disabled: {{ disabled }});
            return JudoTable(
                disabled: {{ disabled }},
                col: {{ col }},
                row: {{ row }} - 1,
                inCard: {{ isInCard }},
                dataInfo: dataInfo,
                rowList: {{# if relation.isAccess }}{{# if relation.isCollection }}pageStore.{{ fqVariable relation.name }}StoreList.asObservable(){{ else }}[pageStore.store].asObservable(){{/ if }}{{ else }}{{# if relation.isCollection }}ownerStore.{{ variable relation.name }}{{ else }}[ownerStore.{{ variable relation.name }}].asObservable(){{/ if }}{{/ if }},
                {{# if relation.isCollection }}
                sortAscending: pageStore.{{ fqVariable relation.name }}SortAsc,
                sortColumnIndex: pageStore.{{ fqVariable relation.name }}SortColumnIndex,
                onSort: (int columnIndex, bool asc) {
                    pageStore.{{ fqVariable relation.name }}SetSort(
                        {{# unless relation.isAccess }}
                        ownerStore,
                        {{/ unless }}
                        context,
                        dataInfo.getColumnFieldByIndex(columnIndex, asc),
                        columnIndex,
                        asc,
                        dataInfo.getSortComparator(columnIndex, asc)
                    );
                },
                {{/ if }}
                {{# each table.rowActions as |action| }}
                {{# if action.isViewAction }}
                navigateToViewPageAction: (element) async {
                    if (element != null) {
                        await navigation.open(Routes.{{ pageClassVariableName action.target.name }}{{# if (tableNavigateToViewHasIdParam page) }}(id: element.internal__signedIdentifier){{/ if }},
                            arguments: {{ pageArgumentsClassName action.target.name }}({{# unless relation.isAccess}}ownerStore: ownerStore, targetStore: element{{/ unless}}));
                        {{# unless relation.isMemberTypeTransient }}
                        pageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess }}ownerStore{{/ unless }})
                            .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                        {{/ unless }}
                    }
                },
                {{/ if }}
                {{# if action.isCreateAction }}
                // TODO: not sure this rowAction needed
                navigateToCreatePageAction:{{# unless relation.isAccess }} targetStore.internal__updatable ?{{/ unless }} (element) async {
                    var created = await navigation.open(Routes.{{ pageClassVariableName action.target.name }});
                    if (created != null) {
                        pageStore.create{{ fqClass relation.name }}({{# unless relation.isAccess }}ownerStore ,{{/ unless }}created)
                            .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                    }
                }{{# unless relation.isAccess }} : null{{/ unless }},
                {{/ if }}
                {{# if action.isEditAction }}
                navigateToEditPageAction:{{# unless relation.isAccess }} ownerStore.internal__updatable ?{{/ unless }} (element) async {
                    {{ storeClassName relationType.target.name }} cloned = {{ storeClassName relationType.target.name }}();
                    cloned.updateWith(element);
                    var res = await navigation.open(Routes.{{ pageClassVariableName action.target.name }},
                        arguments: {{ pageArgumentsClassName action.target.name }}(targetStore: cloned));
                    if (res != null) {
                        element.updateWith(cloned);
                        var updated = await pageStore.update{{ className relation.target.name }}(element)
                            .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                        if (updated != null) {
                            element.updateWith(updated);
                            pageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess }}ownerStore{{/ unless }})
                                .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                        }
                    }
                }{{# unless relation.isAccess }}{{# unless relation.isRelationKindStatic }} : null{{/ unless }}{{/ unless }},
                {{/ if }}
                {{# if action.isRemoveAction }}
                removeAction:{{# unless relation.isAccess }} ownerStore.internal__updatable ?{{/ unless }} (element) => pageStore.remove{{ fqClass relation.name }}(ownerStore, element){{# unless relation.isAccess }} : null{{/ unless }},
                {{/ if }}
                {{# if relationAction.isUnsetAction }}
                unsetAction:{{# unless relation.isAccess }}{{# unless relation.isRelationKindStatic }} targetStore.internal__updatable ?{{/ unless }}{{/ unless }} () async {
                    pageStore.unset{{ fqClass relation.name }}(targetStore)
                        .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                }{{# unless relation.isAccess }}{{# unless relation.isRelationKindStatic }} : null{{/ unless }}{{/ unless }},
                {{/ if }}
                {{# if action.isDeleteAction }}
                deleteAction:{{# unless relation.isAccess }} ownerStore.internal__updatable ?{{/ unless }} (element) async {
                    pageStore.delete{{ className relation.target.name }}(element{{# unless relation.isAccess }}, ownerStore{{/ unless }})
                        .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                }{{# unless relation.isAccess }} : null{{/ unless }},
                {{/ if }}
                {{/ each }}
            );
    }
}),
{{# if relation.isCollection }}
Row(
    children: [
        Padding(
            padding: JudoComponentCustomizer.get().getDefaultPadding(),
            child: Observer(
                builder: (_) => Text(
                    '${pageStore.pageTableItemsRangeStart} - ${pageStore.pageTableItemsRangeStart - 1 + {{# if relation.isAccess }}pageStore.{{ fqVariable relation.name }}StoreList.length{{ else }}ownerStore.{{ variable relation.name }}.length{{/ if }} }',
                    style: JudoComponentCustomizer.get().getRowCounterTextStyle(Theme.of(context)),
                ),
            ),
        ),
        Observer(
            builder: (_) => Padding(
                padding: JudoComponentCustomizer.get().getDefaultPadding(),
                child: ElevatedButton(
                    onPressed: pageStore.previousButtonEnable ? () async {
                        await pageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess }}ownerStore, {{/ unless }}isNext: false);
                    } : null,
                    child: Text(AppLocalizations.of(context).lookUpValue(context, 'Previous')),
                ),
            ),
        ),
        Observer(
            builder: (_) => Padding(
                padding: JudoComponentCustomizer.get().getDefaultPadding(),
                child: ElevatedButton(
                    onPressed: pageStore.nextButtonEnable ? () async {
                        await pageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess }}ownerStore, {{/ unless }}isNext: true);
                    } : null,
                    child: Text(AppLocalizations.of(context).lookUpValue(context, 'Next')),
                ),
            ),
        ),
    ],
),
{{/ if }}
{{/with}}
//END associationtable.dart.hbs-----{{ dataElement.name }}---------------------------------------------------------------------------------
