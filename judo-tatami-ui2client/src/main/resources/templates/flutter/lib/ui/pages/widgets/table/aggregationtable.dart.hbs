{{~ log 'Table generation for' (variable application.name) '-' (fqClass page.name) (variable dataElement.name) level='debug' ~}}
//START aggregationtable.dart.hbs-----{{ dataElement.name }}---------------------------------------------------------------------------------
{{# with dataElement as |relation| }}
Observer(builder: (_) {
    var dataInfo = {{ fqClass pageDefinition.name }}{{ fqClass table.name }}{{ fqClass pageContainer.layoutType.name }}Table(context, disabled: {{ disabled }});
    return JudoTable(
        disabled: {{ disabled }},
        col: {{ col }},
        row: {{ row }} - 1,
        inCard: {{ isInCard }},
        dataInfo: dataInfo,
        rowList: {{# if relation.isCollection }}pageStore.{{ variable relation.name }}TablePagingList{{ else }}[targetStore.{{ variable relation.name }}].asObservable(){{/ if }},
        {{# if relation.isCollection }}
        sortAscending: pageStore.{{ fqVariable relation.name }}SortAsc,
        sortColumnIndex: pageStore.{{ fqVariable relation.name }}SortColumnIndex,
        onSort: (int columnIndex, bool asc) {
          pageStore.{{ fqVariable relation.name }}SetSort(
            context,
            dataInfo.getColumnFieldByIndex(columnIndex, asc),
            columnIndex,
            asc,
            dataInfo.getSortComparator(columnIndex, asc),
            targetStore
          );
        },
        {{/if}}
        {{#each table.rowActions as |rowAction|}}
        {{#if rowAction.isViewAction}}
        navigateToViewPageAction: (element) async {
            if (element != null) {
                var response = await navigation.open(Routes.{{ fqVariable rowAction.target.name }}Page{{# if page.dataElement.isAccess}}(id: element.internal__signedIdentifier){{/ if}},
                arguments: {{ fqClass rowAction.target.name }}PageArguments({{# unless relation.isAccess}}ownerStore: targetStore, {{/ unless}}));
                {{# unless relation.isMemberTypeTransient }}
                    {{# unless page.isPageTypeOperationOutput }}
                if (response != null) {
                    pageStore.refresh{{ className relation.owner.name }}(targetStore)
                        .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                }
                    {{/ unless }}
                {{/ unless }}
            }
        },
        {{/ if }}
        {{# if rowAction.isEditAction }}
        navigateToEditPageAction:{{# unless relation.isAccess }} targetStore.internal__updatable ?{{/ unless }} (element) async {
            {{ storeClassName relationType.target.name }} cloned = {{ storeClassName relationType.target.name }}();
            cloned.updateWith(element);
            var res = await navigation.open(Routes.{{ fqVariable rowAction.target.name }}Page,
            arguments: {{ fqClass rowAction.target.name }}PageArguments(targetStore: cloned, validatable: pageStore.validatable));
            if (res != null) {
                element.updateWith(cloned);
                var updated = await pageStore.update{{ className relation.name }}{{ className relation.target.name }}(element, targetStore)
                    .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                {{# if (isValidateHere page) }}
                    {{# unless page.dataElement.isRelationKindAggregation }}
                        {{# unless page.dataElement.isRelationKindComposition }}
                            {{# unless relation.isMemberTypeTransient }}
                var validate = await pageStore.validate({{# unless page.dataElement.isAccess }}ownerStore, {{/ unless }}targetStore)
                    .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                if (validate != null) {
                    targetStore.updateWith(validate);
                }
                            {{/ unless }}
                        {{/ unless }}
                    {{/ unless }}
                {{ else }}
                if (updated != null) {
                    element.updateWith(updated);
                    pageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess }}targetStore{{/ unless }})
                        .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
                }
                {{/ if }}
            }
        }{{# unless relation.isAccess }} : null{{/ unless }},
        {{/ if }}
        {{# if rowAction.isRemoveAction }}
        removeAction:{{# unless relation.isAccess }}{{# unless relation.isRelationKindStatic }} targetStore.internal__updatable ?{{/ unless }}{{/ unless }} (element) {
            {{# if relation.isRelationBehaviourTypeRemovable }}
            pageStore.remove{{ fqClass relation.name }}(targetStore, element);
            {{ else }}
            var temporaryList = List<{{ storeClassName relation.target.name }}>.from(targetStore.{{ variable relation.name }})
                ..remove(element);
            targetStore.set{{ fqClass relation.name }}(temporaryList);
            {{/ if }}
        }{{# unless relation.isAccess }}{{# unless relation.isRelationKindStatic }} : null{{/ unless }}{{/ unless }},
        {{/ if }}
        {{# if rowAction.isUnsetAction }}
        unsetAction:{{# unless relation.isAccess }}{{# unless relation.isRelationKindStatic }} targetStore.internal__updatable ?{{/ unless }}{{/ unless }} () async {
            pageStore.unset{{ fqClass relation.name }}(targetStore)
                .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
        }{{# unless relation.isAccess }}{{# unless relation.isRelationKindStatic }} : null{{/ unless }}{{/ unless }},
        {{/ if }}
        {{# if rowAction.isDeleteAction }}
        deleteAction:{{# unless relation.isAccess }} targetStore.internal__updatable ?{{/ unless }} (element) async {
            pageStore.delete{{ className relation.name }}{{ className relation.target.name }}(element{{# unless relation.isAccess }}, targetStore{{/ unless }})
                .catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
        }{{# unless relation.isAccess }} : null{{/ unless }},
        {{/ if }}
        {{/ each }}
    );
}),
Row(
    children: [
        Padding(
            padding: JudoComponentCustomizer.get().getDefaultPadding(),
            child: Observer(
                builder: (_) => Text(
                    '${pageStore.{{ variable relation.name }}TableItemsRangeStart} - ${pageStore.{{ variable relation.name }}TableItemsRangeEnd}',
                    style: JudoComponentCustomizer.get().getRowCounterTextStyle(Theme.of(context)),
                ),
            ),
        ),
        Observer(
            builder: (_) => Padding(
                padding: JudoComponentCustomizer.get().getDefaultPadding(),
                child: ElevatedButton(
                    onPressed: pageStore.{{ variable relation.name }}TablePreviousEnable ? () async {
                        pageStore.{{ variable relation.name }}TablePreviousPage();
                    } : null,
                    child: Text(AppLocalizations.of(context).lookUpValue(context, 'Previous')),
                ),
            ),
        ),
        Observer(
            builder: (_) => Padding(
                padding: JudoComponentCustomizer.get().getDefaultPadding(),
                child: ElevatedButton(
                    onPressed: pageStore.{{ variable relation.name }}TableNextEnable ? () async {
                        pageStore.{{ variable relation.name }}TableNextPage();
                    } : null,
                    child: Text(AppLocalizations.of(context).lookUpValue(context, 'Next')),
                ),
            ),
        ),
    ],
),
{{/ with }}
//END aggregationtable.dart.hbs-----{{ dataElement.name }}-----------------------------------------------------------------------------------
