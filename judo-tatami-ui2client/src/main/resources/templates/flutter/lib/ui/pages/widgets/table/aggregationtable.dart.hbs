{{# with dataElement as |relation|}}
JudoColumn(
    col: {{col}},
    row: {{row}},
    mainAxisAlignment: MainAxisAlignment.center,
    crossAxisAlignment: CrossAxisAlignment.start,
    mainAxisSize: MainAxisSize.min,
    children: [
        JudoRow(
            col: {{col}},
            row: 1,
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
            {{# each table.relationActions as |relationAction| }}
                JudoButton(
                    col: {{col}},
                    disabled: {{disabled}},
                {{# if relationAction.isBackAction }}
                    onPressed: () => navigation.close(),
                {{/ if }}
                {{# if relationAction.isCreateAction }}
                    onPressed:{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}{{/ unless}} () async {
                        var created = await navigation.open(Routes.{{ fqVariable relationAction.target.name }}Page{{# unless relation.isAccess}},
                        arguments: {{ fqClass relationAction.target.name }}PageArguments(owner{{ className relation.owner.name }}Store: target{{ className relation.owner.name }}Store){{~/ unless}});
                        if (created != null) {
                            {{ fqVariable page.name }}PageStore.create{{ fqClass relation.name }}({{# unless relation.isAccess}}target{{ className relation.owner.name }}Store ,{{/ unless}}created);
                        {{# unless page.dataElement.isRelationKindAggregation }}
                            {{# unless page.dataElement.isRelationKindComposition }}
                            var validate = await {{ fqVariable page.name }}PageStore.validate{{ fqClass page.dataElement.name }}({{# unless page.dataElement.isAccess}}owner{{ className page.dataElement.owner.name }}Store, {{/unless}}target{{ className page.dataElement.target.name }}Store);
                            if (validate != null) {
                                target{{ className relation.owner.name }}Store.updateWith(validate);
                            } else {
                                // validate message
                            }
                            {{/unless}}
                        {{/ unless }}
                        }
                    }{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} : null{{/ unless}}{{/ unless}},
                {{/ if }}
                {{#if relationAction.isAddAction}}
                    onPressed:{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}{{/ unless}} () async {
                        var selected =
                            {{> templates/flutter/lib/ui/pages/widgets/dialog.dart.hbs relation=relation}}
                        if (selected != null) {
                            {{fqVariable page.name}}PageStore.add{{ fqClass relation.name }}(target{{ className relation.owner.name }}Store, selected);
                        }
                    }{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} : null{{/ unless}}{{/ unless}},
                {{/if}}
                {{#if relationAction.isSetAction}}
                    onPressed:{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}{{/ unless}} () async {
                        var selected =
                            {{> templates/flutter/lib/ui/pages/widgets/dialog.dart.hbs relation=relation}}
                        if (selected != null) {
                            {{fqVariable page.name}}PageStore.set{{ fqClass relation.name }}(target{{ className relation.owner.name }}Store, selected);
                        }
                    }{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} : null{{/ unless}}{{/ unless}},
                {{/if}}
                {{# if relationAction.isNavigationToPageAction }}
                    onPressed: () async {
                        await navigation.open(Routes.{{ fqVariable relationAction.target.name }}Page,
                        arguments: {{ fqClass relationAction.target.name }}PageArguments(owner{{ className relationAction.target.dataElement.owner.name }}Store: target{{ className relationAction.target.dataElement.owner.name }}Store));
                    },
                {{/ if }}
                {{#if label }}
                    label: '{{label}}',
                {{/if}}
                {{#if icon }}
                    icon: Icon(Icons.{{icon.name}}),
                {{/if}}
                    rounded: true,
                ),
            {{/ each }}
            ]
        ),
        JudoRow(
            col: {{col}},
            row: {{row}},
            children: [
                Observer(builder: (_) {
                    return JudoTable(
                        disabled: {{disabled}},
                        col: {{col}},
                        row: {{row}},
                        dataInfo: {{ fqClass pageDefinition.name }}{{ fqClass table.name }}{{ fqClass pageContainer.layoutType.name }}Table(disabled: {{disabled}}),
                        rowList: {{# if relation.isCollection }}target{{ className relation.owner.name }}Store.{{variable relation.name}}{{else}}[target{{ className relation.owner.name }}Store.{{variable relation.name}}].asObservable(){{/ if}},
                        {{#each table.rowActions as |rowAction|}}
                        {{#if rowAction.isViewAction}}
                        navigateToViewPageAction: (element) async {
                            var response = await navigation.open(Routes.{{ fqVariable rowAction.target.name }}Page,
                            arguments: {{ fqClass rowAction.target.name }}PageArguments({{# unless relation.isAccess}}owner{{ className relation.owner.name }}Store: target{{ className relation.owner.name }}Store, {{/ unless}}target{{ className relation.target.name }}Store: element));
                            {{# unless relation.isMemberTypeTransient }}
                            if (response != null) {
                                {{ fqVariable page.name }}PageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess}}target{{ className relation.owner.name }}Store{{/ unless}});
                            }
                            {{/ unless }}
                        },
                        {{/if}}
                        {{#if rowAction.isCreateAction}}
                        {{# unless relation.isAccess}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}} (element) async {
                            var created = await navigation.open(Routes.{{ fqVariable rowAction.target.name }}Page);
                            if (created != null) {
                                {{ fqVariable page.name }}PageStore.create{{ fqClass relation.name }}({{# unless relation.isAccess}}target{{ className relation.owner.name }}Store ,{{/ unless}}created);
                            }
                        }{{# unless relation.isAccess}} : null{{/ unless}},
                        {{/if}}
                        {{#if rowAction.isEditAction}}
                        navigateToEditPageAction:{{# unless relation.isAccess}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}} (element) async {
                            {{ fqClass relationType.target.name }}Store cloned = {{ fqClass relationType.target.name }}Store();
                            cloned.updateWith(element);
                            var res = await navigation.open(Routes.{{ fqVariable rowAction.target.name }}Page,
                            arguments: {{ fqClass rowAction.target.name }}PageArguments(target{{ className relation.target.name }}Store: cloned));
                            if (res != null) {
                                element.updateWith(cloned);
                                var updated = await {{ fqVariable page.name }}PageStore.update{{ className relation.target.name }}(element);
                                if (updated != null) {
                                    element.updateWith(updated);
                                    {{ fqVariable page.name }}PageStore.get{{ fqClass relation.name }}({{# unless relation.isAccess}}target{{ className relation.owner.name }}Store{{/ unless}});
                                }
                            }
                        }{{# unless relation.isAccess}} : null{{/ unless}},
                        {{/if}}
                        {{#if rowAction.isRemoveAction}}
                        removeAction:{{# unless relation.isAccess}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}} (element) => {{fqVariable page.name}}PageStore.remove{{ fqClass relation.name }}(target{{ className relation.owner.name }}Store, element){{# unless relation.isAccess}} : null{{/ unless}},
                        {{/if}}
                        {{#if rowAction.isUnsetAction}}
                        unsetAction:{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}}{{/ unless}} () async {
                            {{fqVariable page.name}}PageStore.unset{{ fqClass relation.name }}(target{{ className relation.owner.name }}Store);
                        }{{# unless relation.isAccess}}{{# unless relation.isRelationKindStatic}} : null{{/ unless}}{{/ unless}},
                        {{/if}}
                        {{#if rowAction.isDeleteAction}}
                        deleteAction:{{# unless relation.isAccess}} target{{ className relation.owner.name }}Store.internal__updatable ?{{/ unless}} (element) async {
                            {{fqVariable page.name}}PageStore.delete{{ className relation.target.name }}(element{{# unless relation.isAccess}}, target{{ className relation.owner.name }}Store{{/unless}});
                        }{{# unless relation.isAccess}} : null{{/ unless}},
                        {{/if}}
                        {{/each}}
                    );
                }),
            ]
        ),
    ]
),
{{/ with}}
