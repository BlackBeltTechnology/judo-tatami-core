{{log 'Stored aggregation action generation for' (variable application.name) '-' (fqClass page.name)'page'(variable relation.name)'relation' level='debug'}}
//START input_page_stored_aggregation_actions.dart.hbs-----{{relaltion.name}}---------------------------------------------------------------------------------
// {{ className relation.name }} stored aggregation in-memory actions
{{# if relation.isCollection }}
@action
Future<List<{{ fqClass relation.target.name }}Store>> add{{fqClass relation.name}}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store, {{ fqClass relation.target.name }}Store selected{{ className relation.target.name }}Store) async {
    try {
        owner{{ className relation.owner.name }}Store.{{variable relation.name}}.addAll([selected{{ className relation.target.name }}Store]);
        return owner{{ className relation.owner.name }}Store.{{variable relation.name}};
    } on ApiException catch (error) {
        errorMessage = "Could not add {{relation.name}}";
        throw error;
    }
}

@action
Future<void> remove{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store, {{ fqClass relation.target.name }}Store selected{{ className relation.target.name }}Store) async {
    try {
        errorMessage = null;
        owner{{ className relation.owner.name }}Store.{{variable relation.name}}.remove(selected{{ className relation.target.name }}Store); // TODO: fix with remove more than 1 element
    } on ApiException catch (error) {
        errorMessage = "Could not remove {{ relation.name }}";
        throw error;
    }
}

{{/if}}
{{# if relation.isRelationBehaviourTypeRangeable }}
@action
Future<List<{{fqClass relation.target.name}}Store>> getRangeFor{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store) async {
    try {
        errorMessage = null;
        var temporaryRangeList = List<{{fqClass relation.target.name}}Store>();
        temporaryRangeList.addAll(await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}RangeOf{{ fqClass relation.name }}ToUpdate(owner{{ className relation.owner.name }}Store));
        return temporaryRangeList;
    } on ApiException catch (error) {
        errorMessage = "Could not get range of {{ relation.name }}";
        throw error;
    }
}

{{/if}}
@action
Future<void> set{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store, {{ fqClass relation.target.name }}Store selected{{ className relation.target.name }}Store) async {
    try {
        errorMessage = null;
        owner{{ className relation.owner.name }}Store.{{variable relation.name}} = {{# if relation.isCollection }}[selected{{ className relation.target.name }}Store].asObservable(){{else}}selected{{ className relation.target.name }}Store{{/ if}};
    } on ApiException catch (error) {
        errorMessage = "Could not set {{ relation.name }}";
        throw error;
    }
}

@action
Future<void> unset{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store) async {
    try {
        errorMessage = null;
        owner{{ className relation.owner.name }}Store.{{variable relation.name}} = null;
    } on ApiException catch (error) {
        errorMessage = "Could not unset {{ relation.name }}";
        throw error;
    }
}

//END input_page_stored_aggregation_actions.dart.hbs-----{{relaltion.name}}-----------------------------------------------------------------------------------
