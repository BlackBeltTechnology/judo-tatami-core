class {{ fqClass page.name }}PageStore extends _{{ fqClass page.name }}PageStore with _${{ fqClass page.name }}PageStore {}

abstract class _{{ fqClass page.name }}PageStore with Store {
    {{# with page.relationType as |relation| }}
    {{ fqClass application.actor.name }}Repository _{{ fqVariable application.actor.name }}Repository = locator<{{ fqClass application.actor.name }}Repository>();

    @observable
    String errorMessage;

    {{# if page.dataElement.isAccess}}
    {{# if relation.isCollection }}
    @observable
    List<{{ fqClass relation.target.name }}Store> {{ fqVariable relation.name }}StoreList = ObservableList<{{ fqClass relation.target.name }}Store>();

    {{/ if }}
    {{/ if }}
    @observable
    ObservableFuture {{ fqVariable relation.name }}StoreFuture;

    {{# if relation.isRelationBehaviourTypeCreatable }}
    @action
    Future<{{ fqClass relation.target.name }}Store> create{{ fqClass relation.name }}({{# unless page.dataElement.isAccess}}{{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store, {{/unless}}{{ fqClass relation.target.name }}Store target{{ className relation.target.name }}Store) async {
        try {
            errorMessage = null;
            var created = await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Create({{# unless page.dataElement.isAccess}}owner{{ className relation.owner.name }}Store, {{/unless}}target{{ className relation.target.name }}Store);
            get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess}}owner{{ className relation.owner.name }}Store{{/unless}});
            return created;
        } on ApiException {
            errorMessage = "Could not create {{ relation.name }}";
        }
    }

    {{/ if }}
	{{#if relation.isRelationBehaviourTypeAddable}}
    @action
    Future<List<{{ fqClass relation.target.name }}Store>> add{{fqClass relation.name}}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store, {{ fqClass relation.target.name }}Store selected{{ className relation.target.name }}Store) async {
        try {
            await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}Add{{fqClass relation.name}}(owner{{ className relation.owner.name }}Store, [selected{{ className relation.target.name }}Store]);
            owner{{ className relation.owner.name }}Store.{{variable relation.name}}.addAll([selected{{ className relation.target.name }}Store]);
            return owner{{ className relation.owner.name }}Store.{{variable relation.name}};
        } on ApiException {
            errorMessage = "Could not add {{relation.name}}";
        }
    }

    {{/if}}
    {{# if relation.isRelationBehaviourTypeRemovable }}
    @action
    Future<void> remove{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store, {{ fqClass relation.target.name }}Store selected{{ className relation.target.name }}Store) async {
        try {
            errorMessage = null;
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}Remove{{fqClass relation.name}}(owner{{ className relation.owner.name }}Store, [selected{{ className relation.target.name }}Store]));
            await {{ relation.name }}StoreFuture;
            owner{{ className relation.owner.name }}Store.{{variable relation.name}}.remove(selected{{ className relation.target.name }}Store); // TODO: fix with remove more than 1 element
        } on ApiException {
            errorMessage = "Could not remove {{ relation.name }}";
        }
    }

    {{/if}}
    {{# if relation.isRelationBehaviourTypeListable }}
    @action
    {{# if relation.isCollection }}Future<List<{{ fqClass relation.target.name }}Store>>{{else}}Future<{{ fqClass relation.target.name }}Store>{{/if}} get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess}}{{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store{{/unless}}) async {
        try {
            errorMessage = null;
            {{# if page.dataElement.isAccess}}
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}List());
            {{ relation.name }}StoreList.clear();
            {{ relation.name }}StoreList.addAll(await {{ relation.name }}StoreFuture);
            return {{ relation.name }}StoreList;
            {{else}}
            {{# if relation.isCollection }}
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}List(owner{{ className relation.owner.name }}Store));
            owner{{ className relation.owner.name }}Store.{{ relation.name }}.clear();
            owner{{ className relation.owner.name }}Store.{{ relation.name }}.addAll(await {{ relation.name }}StoreFuture);
            return owner{{ className relation.owner.name }}Store.{{ relation.name }};
            {{else}}
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Get(owner{{ className relation.owner.name }}Store));
            owner{{ className relation.owner.name }}Store.{{ relation.name }} = await {{ relation.name }}StoreFuture;
            return owner{{ className relation.owner.name }}Store.{{ relation.name }};
            {{/if}}
            {{/if}}
        } on ApiException {
            errorMessage = "Could not load {{ relation.name }}";
        }
    }

    {{/if}}
    {{# if relation.isRelationBehaviourTypeRangeable }}
    @action
    Future<List<{{fqClass relation.target.name}}Store>> getRangeFor{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store) async {
        try {
            errorMessage = null;
            var temporaryRangeList = List<{{fqClass relation.target.name}}Store>();
            {{ fqVariable relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}RangeOf{{ fqClass relation.name }}ToUpdate(owner{{ className relation.owner.name }}Store));
            temporaryRangeList.addAll(await {{ fqVariable relation.name }}StoreFuture);
            return temporaryRangeList;
        } on ApiException {
            errorMessage = "Could not get range of {{ relation.name }}";
        }
    }

    {{/if}}
    {{# if relation.isRelationBehaviourTypeSetable }}
    @action
    Future<void> set{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store, {{ fqClass relation.target.name }}Store selected{{ className relation.target.name }}Store) async {
        try {
            if (selected{{ className relation.target.name }}Store.internal__signedIdentifier != null){
                await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}Set{{ fqClass relation.name }}(owner{{ className relation.owner.name }}Store, {{# if relation.isCollection }}[selected{{ className relation.target.name }}Store]{{else}}selected{{ className relation.target.name }}Store{{/ if}});
            {{# if relation.isRelationBehaviourTypeUnsetable }}
            } else {
                await _{{ fqVariable application.actor.name }}Repository.{{ fqVariable relation.owner.name }}Unset{{ fqClass relation.name }}(owner{{ className relation.owner.name }}Store);
            {{/ if}}
            }
            get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess}}owner{{ className relation.owner.name }}Store{{/unless}});
        } on ApiException {
            errorMessage = "Could not set {{ relation.name }}";
        }
    }

    {{/if}}
    {{# if relation.target.isClassBehaviourTypeDeletable }}
    @action
    Future<void> delete{{ className relation.target.name }}({{ fqClass relation.target.name }}Store target{{ className relation.target.name }}Store{{# unless relation.isAccess}}, {{ fqClass relation.owner.name }}Store owner{{ className relation.owner.name }}Store{{/unless}}) async {
        try {
            errorMessage = null;
            await _{{ fqVariable application.actor.name }}Repository.{{fqVariable relation.target.name}}Delete(target{{ className relation.target.name }}Store);
            get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess}}owner{{ className relation.owner.name }}Store{{/unless}});
        } on ApiException {
            errorMessage = "Could not delete {{ variable relation.target.name }}";
        }
    }

    {{/if}}
    {{# if relation.target.isClassBehaviourTypeUpdatable }}
    @action
    Future<{{ fqClass relation.target.name }}Store> update{{ className relation.target.name }}({{ fqClass relation.target.name }}Store target{{ className relation.target.name }}Store) async {
        try {
            errorMessage = null;
            return await _{{ fqVariable application.actor.name }}Repository.{{fqVariable relation.target.name}}Update(target{{ className relation.target.name }}Store);
        } on ApiException {
            errorMessage = "Could not update {{ variable relation.target.name }}";
        }
    }

    {{/if}}
    {{/ with }}
}
