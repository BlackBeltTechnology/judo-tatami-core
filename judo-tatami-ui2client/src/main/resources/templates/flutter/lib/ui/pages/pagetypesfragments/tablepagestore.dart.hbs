class {{ fqClass page.name }}PageStore extends _{{ fqClass page.name }}PageStore with _${{ fqClass page.name }}PageStore {}

abstract class _{{ fqClass page.name }}PageStore with Store {
    {{# with page.relationType as |relation| }}
    {{ fqClass relation.owner.name }}{{ fqClass relation.name }}Repository _{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository = locator<{{ fqClass relation.owner.name }}{{ fqClass relation.name }}Repository>();

    @observable
    String errorMessage;

    {{# if page.dataElement.isAccess}}
    {{# if relation.isCollection }}
    @observable
    List<{{ fqClass relation.name }}Store> {{ fqVariable relation.name }}ListStore = ObservableList<{{ fqClass relation.name }}Store>();
        
    {{/ if }}
    {{/ if }}
    @observable
    ObservableFuture {{ fqVariable relation.name }}StoreFuture;

    {{# if relation.isRelationBehaviourTypeCreatable }}
    @action
    Future<{{ fqClass relation.target.name }}Store> create{{ fqClass relation.name }}({{# unless page.dataElement.isAccess}}{{ fqClass relation.owner.name }}Store {{ variable relation.owner.name }}Store, {{/unless}}{{ fqClass relation.target.name }}Store {{ variable relation.target.name }}Store) async {
        try {
            errorMessage = null;
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Create({{# unless page.dataElement.isAccess}}{{ variable relation.owner.name }}Store, {{/unless}}{{ variable relation.target.name }}Store));
            return await {{ relation.name }}StoreFuture;
        } on ApiException {
            errorMessage = "Could not create {{ relation.name }}";
        }
    }

    {{/ if }}
	{{#if relation.isRelationBehaviourTypeAddable}}
    @action
    Future<List<{{ fqClass relation.target.name }}Store>> add{{fqClass relation.name}}({{ fqClass relation.owner.name }}Store {{ variable relation.owner.name }}Store, {{ fqClass relation.target.name }}Store selected{{ className relation.target.name }}Store) async {
        try {
            await _{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.owner.name }}{{fqClass relation.name}}Add({{ variable relation.owner.name }}Store, [selected{{ className relation.target.name }}Store]);
            {{ variable relation.owner.name }}Store.{{variable relation.name}}.addAll([selected{{ className relation.target.name }}Store]);
            return {{ variable relation.owner.name }}Store.{{variable relation.name}};
        } on ApiException {
            errorMessage = "Could not add {{relation.name}}";
        }
    }

    {{/if}}
    {{# if relation.isRelationBehaviourTypeRemovable }}
    @action
    Future<void> remove{{ fqClass relation.name }}({{ fqClass relation.target.name }}Store {{ fqVariable relation.target.name }}Store) async {
        try {
            errorMessage = null;
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.target.name }}Delete({{ fqVariable relation.target.name }}Store));
            await {{ relation.name }}StoreFuture;
            {{ relation.name }}ListStore.remove({{ fqVariable relation.target.name }}Store);
        } on ApiException {
            errorMessage = "Could not remove {{ relation.name }}";
        }
    }

    {{/if}}
    {{# if relation.isRelationBehaviourTypeListable }}
    @action
    {{# if relation.isCollection }}Future<List<{{ fqClass relation.target.name }}Store>>{{else}}{{ fqClass relation.target.name }}Store{{/if}} get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess}}{{ fqClass relation.owner.name }}Store {{ variable relation.owner.name }}Store{{/unless}}) async {
        try {
            errorMessage = null;
            {{# if page.dataElement.isAccess}}
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}List());
            {{ relation.name }}ListStore.clear();
            {{ relation.name }}ListStore.addAll(await {{ relation.name }}StoreFuture);
            return {{ relation.name }}ListStore;
            {{else}}
            {{# if relation.isCollection }}
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}List(categoryInfoStore));
            {{ variable relation.owner.name }}Store.{{ relation.name }}.clear();
            {{ variable relation.owner.name }}Store.{{ relation.name }}.addAll(await {{ relation.name }}StoreFuture);
            return {{ variable relation.owner.name }}Store.{{ relation.name }};
            {{else}}
            {{ relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Get(productInfoStore));
            {{ variable relation.owner.name }}Store.{{ relation.name }} = await {{ relation.name }}StoreFuture;
            return {{ variable relation.owner.name }}Store.{{ relation.name }};
            {{/if}}
            {{/if}}
        } on ApiException {
            errorMessage = "Could not load {{ relation.name }}";
        }
    }

    {{/if}}
    {{# if relation.isRelationBehaviourTypeRangeable }}
    @action
    Future<List<{{fqClass relation.target.name}}Store>> getRangeFor{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store {{ variable relation.owner.name }}Store) async {
        try {
            errorMessage = null;
            var temporaryRangeList = List<{{fqClass relation.target.name}}Store>();
            {{ fqVariable relation.name }}StoreFuture = ObservableFuture(_{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.owner.name }}RangeOf{{ fqClass relation.name }}({{ variable relation.owner.name }}Store));
            temporaryRangeList.addAll(await {{ fqVariable relation.name }}StoreFuture);
            return temporaryRangeList;
        } on ApiException {
            errorMessage = "Could not get range of {{ relation.name }}";
        }
    }

    {{/if}}
    {{# if relation.isRelationBehaviourTypeSetable }}
    @action
    Future<void> set{{ fqClass relation.name }}({{ fqClass relation.owner.name }}Store {{ variable relation.owner.name }}Store, {{ fqClass relation.target.name }}Store selected{{ className relation.target.name }}Store) async {
        try {
            if (selected{{ className relation.target.name }}Store.signedIdentifier != null){
                await _{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.owner.name }}Set{{ fqClass relation.name }}({{ variable relation.owner.name }}Store, selected{{ className relation.target.name }}Store);
            {{# if relation.isRelationBehaviourTypeUnsetable }}
            } else {
                await _{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Repository.{{ fqVariable relation.owner.name }}Unset{{ fqClass relation.name }}({{ variable relation.owner.name }}Store);
            {{/ if}}
            }
            {{ variable relation.owner.name }}Store.{{ relation.name }} = selected{{ className relation.target.name }}Store;
        } on ApiException {
            errorMessage = "Could not set {{ relation.name }}";
        }
    }

    {{/if}}
    {{/ with }}
}
