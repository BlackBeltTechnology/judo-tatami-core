{{ log 'Pagestore generation for' (variable application.name) '-' (fqClass page.name) level='debug' }}
//START tablepagestore.dart.hbs-----{{ page.name }}------------------------------------------------------------------------------------------
class {{ pageStoreClassName page.name }} extends _{{ pageStoreClassName page.name }} with _${{ pageStoreClassName page.name }} {}

abstract class _{{ pageStoreClassName page.name }} with Store {
    {{# with page.relationType as |relation| }}
    {{ repositoryClassName application.actor.name }} _actorRepository = locator<{{ repositoryClassName application.actor.name }}>();

    @observable
    String errorMessage;

    @observable
    {{ storeClassName relation.target.name }} targetStore;

    {{# each page.containers.[0].tables as |table| }}
        {{# if table.pageDefinition.relationType.isFilterable }}
    final Map<String, FilterStore> stringFilterStoreMap = {
            {{# each table.filters as |filter| }}
        '{{ variable filter.attributeType.name }}' : FilterStore(attributeName: '{{ variable filter.attributeType.name }}', attributeLabel: '{{ filter.label }}', filterType: FilterType.{{ filterDataType filter.attributeType.dataType }}{{# if (isEnumType filter.attributeType.dataType) }}, enumValues: {{ className filter.attributeType.dataType.name }}.values{{/ if }}),
            {{/ each }}
    };

    // final String mask = '{
    {{~# each (getAttributeTypeNamesFromColumnsAndAttributes page.containers.[0].tables.[0].filters relation.target.attributes) as |attributeName| ~}}
        {{ variable attributeName }}{{# unless @last }},{{/ unless }}
    {{~/ each ~}}
    }';

    @computed
    int get getPlusRowSize => availableFilterList.length;

    @observable
    ObservableList<FilterStore> availableFilterList = <FilterStore>[].asObservable();

    @action
    void addNewFilter(FilterStore newFilterStore) => availableFilterList.add(FilterStore.clone(newFilterStore));

        {{/ if }}
    @observable
    int {{ fqVariable table.pageDefinition.relationType.name }}QueryLimit = ({{ table.row }} - 2).round();

    @action
    void set{{ fqClass table.pageDefinition.relationType.name }}QueryLimit(double queryLimit) {
        {{ fqVariable table.pageDefinition.relationType.name }}QueryLimit = queryLimit.round();
    }
    {{/ each }}

    {{# if relation.isCollection }}
        {{# if page.dataElement.isAccess }}
    @observable
    List<{{ storeClassName relation.target.name }}> {{ fqVariable relation.name }}StoreList = ObservableList<{{ storeClassName relation.target.name }}>();

    @computed
    bool get nextButtonEnable => {{ fqVariable relation.name }}StoreList.length == {{ fqVariable relation.name }}QueryLimit && !nextPageIsEmpty;
        {{ else }}
    @observable
    bool nextButtonEnable = true;
        {{/ if }}

    @computed
    int get pageTableItemsRangeStart => nextPageCounter * {{ fqVariable relation.name }}QueryLimit + 1;

    @observable
    int nextPageCounter = 0;

    @computed
    bool get previousButtonEnable => nextPageCounter > 0;

    @observable
    bool nextPageIsEmpty = false;

    @observable
    int {{ fqVariable relation.name }}SortColumnIndex;

    @observable
    String {{ fqVariable relation.name }}SortColumnName;

    @observable
    bool {{ fqVariable relation.name }}SortAsc;

    @observable
    Comparator {{ fqVariable relation.name }}SortCompare;


    @action
    void {{ fqVariable relation.name }}SetSort({{# unless page.dataElement.isAccess }}{{ storeClassName relation.owner.name }} ownerStore, {{/ unless }}BuildContext context, String sortColumnName, int sortColumnIndex, bool asc, Comparator sortCompare) {

        if ({{ fqVariable relation.name }}SortColumnIndex != sortColumnIndex) {
          {{ fqVariable relation.name }}SortAsc = true;
        } else {
          {{ fqVariable relation.name }}SortAsc = !{{ fqVariable relation.name }}SortAsc;
        }

        {{ fqVariable relation.name }}SortColumnIndex = sortColumnIndex;
        {{ fqVariable relation.name }}SortColumnName = sortColumnName;
        {{ fqVariable relation.name }}SortCompare = sortCompare;
        {{# if relation.isOrderable }}
        get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess }}ownerStore{{/ unless }}).catchError((error) => ErrorHandler.showErrorSnack(context, error.message));
        {{ else }}
            {{# if page.dataElement.isAccess }}
        {{ fqVariable relation.name }}StoreList.sort(sortCompare);
            {{ else }}
        ownerStore.{{ variable relation.name }}.sort(sortCompare);
            {{/ if }}
        {{/ if }}
    }
    {{ else }}
    {{# if page.dataElement.isAccess }}
    @observable
    {{ storeClassName relation.target.name }} store;
    {{/ if }}
    {{/ if }}

    @observable
    ObservableFuture {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture;

    {{# if relation.isRelationBehaviourTypeCreatable }}
    @action
    Future<{{ storeClassName relation.target.name }}> create{{ fqClass relation.name }}({{# unless page.dataElement.isAccess }}{{ storeClassName relation.owner.name }} ownerStore, {{/ unless }}{{ storeClassName relation.target.name }} targetStore) async {
        try {
            errorMessage = null;
            var created = await _actorRepository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Create({{# unless page.dataElement.isAccess }}ownerStore, {{/ unless }}targetStore);
            get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess }}ownerStore{{/ unless }});
            return created;
        } on ApiException catch (error) {
            errorMessage = "Could not create {{ relation.name }}";
            throw error;
        }
    }

    {{/ if }}
	{{# if relation.isRelationBehaviourTypeAddable }}
    @action
    Future<List<{{ storeClassName relation.target.name }}>> add{{ fqClass relation.name }}({{ storeClassName relation.owner.name }} ownerStore, List<{{ storeClassName relation.target.name }}> selectedStore) async {
        try {
            await _actorRepository.{{ fqVariable relation.owner.name }}Add{{ fqClass relation.name }}(ownerStore, selectedStore);
            ownerStore.{{ variable relation.name }}.addAll(selectedStore);
            return ownerStore.{{ variable relation.name }};
        } on ApiException catch (error) {
            errorMessage = "Could not add {{ relation.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeRemovable }}
    @action
    Future<void> remove{{ fqClass relation.name }}({{ storeClassName relation.owner.name }} ownerStore, {{ storeClassName relation.target.name }} selectedStore) async {
        try {
            errorMessage = null;
            {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture = ObservableFuture(_actorRepository.{{ fqVariable relation.owner.name }}Remove{{ fqClass relation.name }}(ownerStore, [selectedStore]));
            await {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture;
            ownerStore.{{ variable relation.name }}.remove(selectedStore); // TODO: fix with remove more than 1 element
        } on ApiException catch (error) {
            errorMessage = "Could not remove {{ relation.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeListable }}
    @action
    {{# if relation.isCollection }}Future<List<{{ storeClassName relation.target.name }}>>{{ else }}Future<{{ storeClassName relation.target.name }}>{{/ if }} get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess }}{{ storeClassName relation.owner.name }} ownerStore, {{/ unless }}{ int queryLimit, bool isNext }) async {
        try {
            errorMessage = null;
        {{# if relation.isCollection }}
        if(isNext == null) {
            nextPageCounter = 0;
        }

        {{/ if }}
        {{# if page.dataElement.isAccess }}
            {{# if relation.isCollection }}
            {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture = ObservableFuture(_actorRepository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}List(
                sortColumn: {{ fqVariable relation.name }}SortColumnName,
                sortAscending: {{ fqVariable relation.name }}SortAsc,
                    {{# if relation.isFilterable }}
                filterStoreList: availableFilterList,
                    {{/ if }}
                queryLimit: queryLimit ?? {{ fqVariable relation.name }}QueryLimit,
                // mask: mask,
                lastItem: isNext != null ?
                (isNext ? {{ fqVariable relation.name }}StoreList.last : {{ fqVariable relation.name }}StoreList.first)
                    : null,
                reverse: isNext != null ?
                !isNext
                    : null,
            ));

            List<{{ storeClassName relation.target.name }}> nextItemsList = await {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture;
            if (nextItemsList.isEmpty) {
                nextPageIsEmpty = true;
                return {{ fqVariable relation.name }}StoreList;
            }

            nextPageIsEmpty = false;
            if(isNext != null) {
                if (isNext) {
                    nextPageCounter++;
                } else {
                    nextPageCounter--;
                }
            }

            {{ fqVariable relation.name }}StoreList.clear();
            {{ fqVariable relation.name }}StoreList.addAll(nextItemsList);

                {{# unless relation.isOrderable }}
            if ({{ fqVariable relation.name }}SortCompare != null) {
                {{ fqVariable relation.name }}StoreList.sort({{ fqVariable relation.name }}SortCompare);
            }
                {{/ unless }}

            return {{ fqVariable relation.name }}StoreList;
            {{ else }}
            {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture = ObservableFuture(_actorRepository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Get(
                // mask: mask,
            ));
            store = await {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture;
            return store;
            {{/ if }}
        {{ else }}
            {{# if relation.isCollection }}
            {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture = ObservableFuture(_actorRepository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}List(
                ownerStore,
                sortColumn: {{ fqVariable relation.name }}SortColumnName,
                sortAscending: {{ fqVariable relation.name }}SortAsc,
                    {{# if relation.isFilterable }}
                filterStoreList: availableFilterList,
                queryLimit: queryLimit ?? {{ fqVariable relation.name }}QueryLimit,
                // mask: mask,
                lastItem: isNext != null ?
                (isNext ? ownerStore.{{ variable relation.name }}.last : ownerStore.{{ variable relation.name }}.first)
                    : null,
                reverse: isNext != null ?
                !isNext
                    : null,
                    {{/ if }}
            ));

            List<{{ storeClassName relation.target.name }}> nextItemsList = await {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture;
            if (nextItemsList.isEmpty) {
                nextButtonEnable = false;
                return ownerStore.{{ variable relation.name }};
            }

            nextButtonEnable = true && nextItemsList.length >= {{ fqVariable relation.name }}QueryLimit;
            if(isNext != null) {
                if (isNext) {
                    nextPageCounter++;
                } else {
                    nextPageCounter--;
                }
            }

            ownerStore.{{ variable relation.name }}.clear();
            ownerStore.{{ variable relation.name }}.addAll(nextItemsList);
                    {{# unless relation.isOrderable }}
            if ({{ fqVariable relation.name }}SortCompare != null) {
                    ownerStore.{{ variable relation.name }}.sort({{ fqVariable relation.name }}SortCompare);
            }
                    {{/ unless }}
            return ownerStore.{{ variable relation.name }};
            {{ else }}
            {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture = ObservableFuture(_actorRepository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Get(
                ownerStore,
                // mask: mask,
            ));
            ownerStore.{{ variable relation.name }} = await {{ variable relation.owner.name }}{{ fqClass relation.name }}StoreFuture;
            return ownerStore.{{ variable relation.name }};
            {{/ if }}
        {{/ if }}
        } on ApiException catch (error) {
            errorMessage = "Could not load {{ relation.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeRangeable }}
        {{# unless relation.isCollection }}
    @observable
    int {{ fqVariable relation.name }}SortColumnIndex;

    @observable
    String {{ fqVariable relation.name }}SortColumnName;

    @observable
    bool {{ fqVariable relation.name }}SortAsc;

    @observable
    Comparator {{ fqVariable relation.name }}SortCompare;
        {{/ unless }}
    {{/ if }}

    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/range_actions.dart.hbs page=page relation=relation}}

    {{# if relation.isRelationBehaviourTypeSetable }}
    @action
    Future<void> set{{ fqClass relation.name }}({{ storeClassName relation.owner.name }} ownerStore, {{# if relation.isCollection }}List<{{ storeClassName relation.target.name }}>{{ else }}{{ storeClassName relation.target.name }}{{/ if }} selectedStore) async {
        try {
            errorMessage = null;
            await _actorRepository.{{ fqVariable relation.owner.name }}Set{{ fqClass relation.name }}(ownerStore, selectedStore);
            get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess }}ownerStore{{/ unless }});
        } on ApiException catch (error) {
            errorMessage = "Could not set {{ relation.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeUnsetable }}
    @action
    Future<void> unset{{ fqClass relation.name }}({{ storeClassName relation.owner.name }} ownerStore) async {
        try {
            errorMessage = null;
            await _actorRepository.{{ fqVariable relation.owner.name }}Unset{{ fqClass relation.name }}(ownerStore);
            get{{ fqClass relation.name }}({{# unless relation.isAccess }}ownerStore{{/ unless }});
        } on ApiException catch (error) {
            errorMessage = "Could not unset {{ relation.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeDeletable }}
    @action
    Future<void> delete{{ className relation.target.name }}({{ storeClassName relation.target.name }} targetStore{{# unless relation.isAccess }}, {{ storeClassName relation.owner.name }} ownerStore{{/ unless }}) async {
        try {
            errorMessage = null;
            await _actorRepository.{{ fqVariable relation.target.name }}Delete(targetStore);
            get{{ fqClass relation.name }}({{# unless page.dataElement.isAccess }}ownerStore{{/ unless }});
        } on ApiException catch (error) {
            errorMessage = "Could not delete {{ relation.target.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeUpdatable }}
    @action
    Future<{{ storeClassName relation.target.name }}> update{{ className relation.target.name }}({{ storeClassName relation.target.name }} targetStore) async {
        try {
            errorMessage = null;
            return await _actorRepository.{{ fqVariable relation.target.name }}Update(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not update {{ relation.target.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{/ with }}
}
//END tablepagestore.dart.hbs-----{{ page.name }}--------------------------------------------------------------------------------------------
