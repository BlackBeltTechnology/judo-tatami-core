{{ log 'Pagestore generation for' (variable application.name) '-' (fqClass page.name) level='debug' }}
//START viewpagestore.dart.hbs-----{{ page.name }}-------------------------------------------------------------------------------------------
class {{ pageStoreClassName page }} extends _{{ pageStoreClassName page }} with _${{ pageStoreClassName page }} {}

abstract class _{{ pageStoreClassName page }} with Store {
    {{# with page.relationType as |relation| }}
    {{ repositoryClassName application.actor }} _actorRepository = locator<{{ repositoryClassName application.actor }}>();

    @observable
    String errorMessage;

    @observable
    {{ storeClassName relation.target }} targetStore;

    {{# if (validatableFlagNeed relation) }}
    bool validatable = true;
    {{/ if }}

    {{# if page.isPageTypeDashboard }}
        {{# if relation.isRelationBehaviourTypeListable }}

    @observable
    ObservableFuture {{ fqVariable relation.name }}StoreFuture;

    @observable
    FutureStatus getterStatus = FutureStatus.pending;

    @action
    void getterStatusSetFulfilled(){
        if({{ fqVariable relation.name }}StoreFuture.status == FutureStatus.fulfilled){
            getterStatus = FutureStatus.fulfilled;
        }
    }

    @action
    void getterStatusSetRejected(){
        getterStatus = FutureStatus.rejected;
    }

    @action
    Future<{{ storeClassName relation.target }}> get{{ fqClass relation.name }}() async {
        try {
            errorMessage = null;
            {{ fqVariable relation.name }}StoreFuture = ObservableFuture(_actorRepository.{{ fqVariable relation.owner.name }}{{ fqClass relation.name }}Get(
                // mask: '{
                    {{~# with page.containers.[0] as |container| ~}}
                        {{~# each (getAttributeTypeNamesFromWidgets container) as |attributeName| ~}}
                            {{~ variable attributeName }}{{# unless @last }},{{/ unless ~}}
                        {{~/ each ~}}
                        {{~# unless (isEmptyList container.tables) }},{{/ unless ~}}
                        {{~# each container.tables as |table| ~}}
                            {{ variable table.dataElement.name ~}}
                            {
                            {{~# each table.columns as |column| ~}}
                        {{~ variable column.attributeType.name }}{{# unless @last }},{{/ unless ~}}
                            {{~/ each ~}}
                            }{{# unless @last }},{{/ unless ~}}
                        {{~/ each ~}}
                    {{~/ with ~}}
                }',
            ));
            return await {{ fqVariable relation.name }}StoreFuture;
        } on ApiException catch (error) {
            errorMessage = "Could not load {{ relation.name }}";
            throw error;
        }
    }

        {{/ if }}
    {{/ if }}
    {{# if relation.isRelationBehaviourTypeRefreshable }}
    @action
    Future<void> refresh{{ className relation.target.name }}({{ storeClassName relation.target }} targetStore) async {
        try {
            errorMessage = null;
            targetStore.updateWith(await _actorRepository.{{ fqVariable relation.target.name }}GetByIdentifier(
                targetStore,
                // mask: '{
                    {{~# with page.containers.[0] as |container| ~}}
                        {{~# each (getAttributeTypeNamesFromWidgets container) as |attributeName| ~}}
                            {{~ variable attributeName }}{{# unless @last }},{{/ unless ~}}
                        {{~/ each ~}}
                        {{~# unless (isEmptyList container.tables) }},{{/ unless ~}}
                        {{~# each container.tables as |table| ~}}
                            {{ variable table.dataElement.name ~}}
                            {
                            {{~# each table.columns as |column| ~}}
                        {{~ variable column.attributeType.name }}{{# unless @last }},{{/ unless ~}}
                            {{~/ each ~}}
                            }{{# unless @last }},{{/ unless ~}}
                        {{~/ each ~}}
                        {{~# unless (isEmptyList container.links) }},{{/ unless ~}}
                        {{~# each container.links as |link| ~}}
                            {{ variable link.dataElement.name ~}}
                            {
                            {{~# each link.columns as |column| ~}}
                                {{~ variable column.attributeType.name }}{{# unless @last }},{{/ unless ~}}
                            {{~/ each ~}}
                            }{{# unless @last }},{{/ unless ~}}
                        {{~/ each ~}}
                    {{~/ with ~}}
                }',
            ));
        } on ApiException catch (error) {
            errorMessage = "Could not refresh {{ relation.target.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeUpdatable }}
    @action
    Future<{{ storeClassName relation.target }}> update{{ className relation.target.name }}({{ storeClassName relation.target }} targetStore) async {
        try {
            errorMessage = null;
            return await _actorRepository.{{ fqVariable relation.target.name }}Update(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not update {{ relation.target.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeDeletable }}
    @action
    Future<void> delete{{ className relation.target.name }}({{ storeClassName relation.target }} targetStore) async {
        try {
            errorMessage = null;
            await _actorRepository.{{ fqVariable relation.target.name }}Delete(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not delete {{ relation.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{# if relation.isRelationBehaviourTypeUpdateValidatable }}
    @action
    Future<{{ storeClassName relation.target }}> validate({{# unless page.dataElement.isAccess }}{{ storeClassName relation.owner }} ownerStore, {{/ unless }}{{ storeClassName relation.target }} targetStore) async {
        try {
            errorMessage = null;
            return await _actorRepository.{{ fqVariable relation.target.name }}ValidateForUpdate(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not validate {{ relation.target.name }}";
            throw error;
        }
    }

    {{/ if }}
    {{/ with }}

{{# each page.containers.[0].tables as |table| }}
    @observable
    int {{ fqVariable table.dataElement.name }}QueryLimit = ({{ table.row }} - 2).round();

    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/embedded_table_paging_actions.dart.hbs table=table page=page relation=table.dataElement }}

    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/range_actions.dart.hbs page=page relation=table.dataElement table=table }}
{{/ each }}
{{# each page.containers.[0].links as |link| }}
    @observable
    int {{ fqVariable link.dataElement.name }}QueryLimit = 5; // For judo link setter dialog

    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/range_actions.dart.hbs page=page relation=link.dataElement table=link }}
{{/ each }}

{{# each page.dataElement.target.relations as |relation| }}
    {{# unless isRelationKindStatic }}
        {{# unless isRelationKindAssociation }}
    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/embedded_collection_table_order_action.dart.hbs page=page relation=relation}}
        {{/ unless }}
    {{/ unless }}
    {{# unless isMemberTypeTransient }}
        {{# if isRelationKindAggregation }}
    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/aggregationactions.dart.hbs page=page relation=relation }}
        {{/ if }}
        {{# if isRelationKindComposition }}
    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/aggregationactions.dart.hbs page=page relation=relation }}
        {{/ if }}
    {{/ unless }}
{{/ each }}

    //OPERATIONS
{{# each page.dataElement.target.operations as |operation| }}
    @action
    {{# if operation.output }}Future<{{# if operation.output.isCollection }}List<{{ storeClassName operation.output.target }}>{{ else }}{{ storeClassName operation.output.target }}{{/ if }}>{{ else }}Future<void>{{/ if }} {{ fqVariable operation.owner.name }}{{ className operation.name }}({{# if operation.input }}{{ storeClassName operation.input.target }} targetStore, {{/ if }}{{# if operation.isMapped }}{{ storeClassName operation.owner }} ownerStore{{/ if }}) async {
        try {
            errorMessage = null;
            {{# if operation.output }}return {{/ if }}await _actorRepository.{{ fqVariable operation.owner.name }}{{ className operation.name }}({{# if operation.input }}targetStore, {{/ if }}{{# if operation.isMapped }}ownerStore{{/ if }});
        } on ApiException catch (error) {
            errorMessage = "Could not call operation {{ operation.name }}";
            throw error;
        }
    }
{{/ each }}
}
//END viewpagestore.dart.hbs-----{{ page.name }}---------------------------------------------------------------------------------------------
