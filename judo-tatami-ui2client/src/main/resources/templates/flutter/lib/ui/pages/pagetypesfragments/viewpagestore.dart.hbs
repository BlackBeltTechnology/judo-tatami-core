{{log 'Pagestore generation for' (variable application.name) '-' (fqClass page.name) level='debug'}}
//START viewpagestore.dart.hbs-----{{page.name}}-------------------------------------------------------------------------------------------
class {{fqClass page.name}}PageStore extends _{{fqClass page.name}}PageStore with _${{fqClass page.name}}PageStore {}

abstract class _{{fqClass page.name}}PageStore with Store {
    {{#with page.relationType as |relation|}}
    {{fqClass application.actor.name}}Repository _{{fqVariable application.actor.name}}Repository = locator<{{fqClass application.actor.name}}Repository>();

    @observable
    String errorMessage;

    {{#if (validatableFlagNeed relation)}}
    bool validatable = true;
    {{/if}}

    /*
    {{#if relation.isCollection}}
    @observable
    int {{fqVariable relation.name}}SortColumnIndex;

    @observable
    String {{fqVariable relation.name}}SortColumnName;

    @observable
    bool {{fqVariable relation.name}}SortAsc;

    @observable
    Comparator {{fqVariable relation.name}}SortCompare;

    @action
    void {{fqVariable relation.name}}SetSort(BuildContext context, String sortColumnName, int sortColumnIndex, bool asc, Comparator sortCompare) {

        if ({{fqVariable relation.name}}SortColumnIndex != sortColumnIndex) {
            {{fqVariable relation.name}}SortAsc = true;
        } else {
            {{fqVariable relation.name}}SortAsc = !{{fqVariable relation.name}}SortAsc;
        }
        {{fqVariable relation.name}}SortColumnIndex = sortColumnIndex;
        {{fqVariable relation.name}}SortColumnName = sortColumnName;
        {{fqVariable relation.name}}SortCompare = sortCompare;
        {{#if relation.isOrderable}}
        get{{fqClass relation.name}}().catchError((error) => ErrorHandler.errorDialog(context, error));
    {{else}}
        {{fqVariable relation.name}}StoreList.sort(sortCompare);
    {{/if}}
    }
    {{/if}}
    */
    {{#if page.isPageTypeDashboard}}
        {{#if relation.isRelationBehaviourTypeListable}}

    @observable
    ObservableFuture {{fqVariable relation.name}}StoreFuture;

    @observable
    FutureStatus getterStatus = FutureStatus.pending;

    @action
    void getterStatusSetFulfilled(){
        if({{fqVariable relation.name}}StoreFuture.status == FutureStatus.fulfilled){
            getterStatus = FutureStatus.fulfilled;
        }
    }

    @action
    void getterStatusSetRejected(){
        getterStatus = FutureStatus.rejected;
    }

    @action
    Future<{{storeClassName relation.target.name}}> get{{fqClass relation.name}}() async {
        try {
            errorMessage = null;
            {{fqVariable relation.name}}StoreFuture = ObservableFuture(_{{fqVariable application.actor.name}}Repository.{{fqVariable relation.owner.name}}{{fqClass relation.name}}Get(
                mask: '{
                    {{~#with page.containers.[0] as |container|~}}
                        {{~#each (getAttributeTypeNamesFromWidgets container) as |attributeName|~}}
                            {{~variable attributeName}}{{#unless @last}},{{/unless~}}
                        {{~/each~}}
                        {{~#unless (isEmptyList container.tables)}},{{/unless~}}
                        {{~#each container.tables as |table|~}}
                            {{variable table.dataElement.name~}}
                            {
                            {{~#each table.columns as |column|~}}
                        {{~variable column.attributeType.name}}{{#unless @last}},{{/unless~}}
                            {{~/each~}}
                            }{{#unless @last}},{{/unless~}}
                        {{~/each~}}
                    {{~/with~}}
                }',
            ));
            return await {{fqVariable relation.name}}StoreFuture;
        } on ApiException catch (error) {
            errorMessage = "Could not load {{relation.name}}";
            throw error;
        }
    }

        {{/if}}
    {{/if}}
    {{#if relation.isRelationBehaviourTypeRefreshable}}
    @action
    Future<void> refresh{{className relation.target.name}}({{storeClassName relation.target.name}} targetStore) async {
        try {
            errorMessage = null;
            targetStore.updateWith(await _{{fqVariable application.actor.name}}Repository.{{fqVariable relation.target.name}}GetByIdentifier(
                targetStore,
                mask: '{
                    {{~#with page.containers.[0] as |container|~}}
                        {{~#each (getAttributeTypeNamesFromWidgets container) as |attributeName|~}}
                            {{~variable attributeName}}{{#unless @last}},{{/unless~}}
                        {{~/each~}}
                        {{~#unless (isEmptyList container.tables)}},{{/unless~}}
                        {{~#each container.tables as |table|~}}
                            {{variable table.dataElement.name~}}
                            {
                            {{~#each table.columns as |column|~}}
                        {{~variable column.attributeType.name}}{{#unless @last}},{{/unless~}}
                            {{~/each~}}
                            }{{#unless @last}},{{/unless~}}
                        {{~/each~}}
                    {{~/with~}}
                }',
            ));
        } on ApiException catch (error) {
            errorMessage = "Could not refresh {{relation.target.name}}";
            throw error;
        }
    }

    {{/if}}
    {{#if relation.isRelationBehaviourTypeUpdatable}}
    @action
    Future<{{storeClassName relation.target.name}}> update{{className relation.target.name}}({{storeClassName relation.target.name}} targetStore) async {
        try {
            errorMessage = null;
            return await _{{fqVariable application.actor.name}}Repository.{{fqVariable relation.target.name}}Update(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not update {{relation.target.name}}";
            throw error;
        }
    }

    {{/if}}
    {{#if relation.isRelationBehaviourTypeDeletable}}
    @action
    Future<void> delete{{className relation.target.name}}({{storeClassName relation.target.name}} targetStore) async {
        try {
            errorMessage = null;
            await _{{fqVariable application.actor.name}}Repository.{{fqVariable relation.target.name}}Delete(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not delete {{relation.name}}";
            throw error;
        }
    }

    {{/if}}
    {{#if relation.isRelationBehaviourTypeUpdateValidatable}}
    @action
    Future<{{storeClassName relation.target.name}}> validate({{#unless page.dataElement.isAccess}}{{storeClassName relation.owner.name}} ownerStore, {{/unless}}{{storeClassName relation.target.name}} targetStore) async {
        try {
            errorMessage = null;
            return await _{{fqVariable application.actor.name}}Repository.{{fqVariable relation.target.name}}ValidateForUpdate(targetStore);
        } on ApiException catch (error) {
            errorMessage = "Could not validate {{relation.target.name}}";
            throw error;
        }
    }

    {{/if}}
    {{/with}}
    {{#each page.dataElement.target.relations as |relation|}}
        {{#unless isMemberTypeTransient}}
            {{#if isRelationKindAggregation}}
    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/aggregationactions.dart.hbs page=page relation=relation}}
            {{/if}}
            {{#if isRelationKindComposition}}
    {{> templates/flutter/lib/ui/pages/pagetypesfragments/storeactions/aggregationactions.dart.hbs page=page relation=relation}}
            {{/if}}
        {{/unless}}
    {{/each}}

    //OPERATIONS
    {{#each page.dataElement.target.operations as |operation|}}
    @action
    {{#if operation.output}}Future<{{#if operation.output.isCollection}}List<{{storeClassName operation.output.target.name}}>{{else}}{{storeClassName operation.output.target.name}}{{/if}}>{{else}}Future<void>{{/if}} {{fqVariable operation.owner.name}}{{className operation.name}}({{#if operation.input}}{{storeClassName operation.input.target.name}} targetStore, {{/if}}{{#if operation.isMapped}}{{storeClassName operation.owner.name}} ownerStore{{/if}}) async {
        try {
            errorMessage = null;
            {{#if operation.output}}return {{/if}}await _{{fqVariable application.actor.name}}Repository.{{fqVariable operation.owner.name}}{{className operation.name}}({{#if operation.input}}targetStore, {{/if}}{{#if operation.isMapped}}ownerStore{{/if}});
        } on ApiException {
            errorMessage = "Could not call operation {{operation.name}}";
        }
    }
    {{/each}}
}
//END viewpagestore.dart.hbs-----{{page.name}}---------------------------------------------------------------------------------------------
