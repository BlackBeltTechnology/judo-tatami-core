// ignore: avoid_web_libraries_in_flutter
import 'dart:html' as html;

import 'package:dio/dio.dart';
import 'package:flutter_appauth_platform_interface/flutter_appauth_platform_interface.dart';
import 'package:flutter_appauth_web/flutter_appauth_web.dart';
import 'package:openapi_dart_common/openapi.dart';
import 'injector/injector.dart';
import 'dart:async';

class Oauth {
  static const AUTH_CODE_VERIFIER_KEY = "auth_code_verifier";
  static const AUTH_CODE_KEY = "auth_code";
  static const AUTH_ACCESS_TOKEN_KEY = "auth_access_token";
  static const AUTH_ACCESS_TOKEN_EXPIRE = "auth_access_token_expire";
  static const AUTH_REFRESH_TOKEN_KEY = "auth_refresh_token";
  static const AUTH_DESTINATION_URL = "auth_destination_url";
  static const GRANT_AUTHORIZATION = "authorization_code";
  static const GRANT_REFRESH = "refresh_token";

  //Judo specific
  static const ISSUER = "http://localhost:8080/auth/realms/JUDO";
  static const SCOPES = ["email"];
  static const CALLBACK_URL = "http://localhost:8888/";
  static const CLIENT_ID = "Judo_Default_Project-User";
  static const REALM = "JUDO";
  static const LOGOUT_URL = "http://localhost:8080/auth/realms/JUDO/protocol/openid-connect/logout?redirect_uri=http%3A%2F%2Flocalhost%3A8888%2F";

  static loadBackendMetaData() {
  //TODO implement load meta data from backend
  }

  static bool isAuthenticationRequired() {
    // TODO add meta response check
    return true;
  }

  static Future<String> processLogin() async {
    if (!isLoggedIn()) {
      var authResponse = AppAuthWebPlugin.processLoginResult(
          html.window.location.href,
          html.window.sessionStorage[AUTH_CODE_VERIFIER_KEY]);

      if (authResponse != null) {
          html.window.sessionStorage[AUTH_CODE_KEY] = authResponse.authorizationCode;
          return await requestToken(GRANT_AUTHORIZATION);
      }
      return null;
    }
    return html.window.sessionStorage[AUTH_ACCESS_TOKEN_KEY];
  }

  static Future loginAuthorizeAndExchangeCode() async {
    if (html.window.sessionStorage[AUTH_CODE_VERIFIER_KEY] == null || html.window.sessionStorage[AUTH_CODE_VERIFIER_KEY].isEmpty) {
      var auth = AppAuthWebPlugin();
      var request = AuthorizationTokenRequest(
          CLIENT_ID,
          CALLBACK_URL,
          issuer: ISSUER,
          scopes: SCOPES);
      await auth.authorizeAndExchangeCode(request);
    }
  }

  static Future<String> requestToken(String grantType) async {
        // print("authResponse: ${authResponse.authorizationCode}");
        var tokenRequest = TokenRequest(
            CLIENT_ID,
            CALLBACK_URL,
            scopes: SCOPES,
            grantType: grantType,
            authorizationCode: html.window.sessionStorage[AUTH_CODE_KEY],
            codeVerifier: html.window.sessionStorage[AUTH_CODE_VERIFIER_KEY],
            refreshToken: grantType == GRANT_REFRESH ? html.window.sessionStorage[AUTH_REFRESH_TOKEN_KEY]: null,
            issuer: ISSUER);

        var token = await AppAuthWebPlugin.requestToken(tokenRequest);
        html.window.sessionStorage[AUTH_ACCESS_TOKEN_KEY] = token.accessToken;
        html.window.sessionStorage[AUTH_ACCESS_TOKEN_EXPIRE] = token.accessTokenExpirationDateTime.toString();
        html.window.sessionStorage[AUTH_REFRESH_TOKEN_KEY] = token.refreshToken;

        // print('Access token: ${token.accessToken}');
        // print('Refresh token: ${token.refreshToken}');
        // print(token.accessTokenExpirationDateTime);

        return token.accessToken;
  }

  static bool addTokenToApiClient(String token) {
    if (token != null) {
      locator<ApiClient>().setAuthentication(REALM, OAuth(accessToken: token));
      return true;
    }
    return false;
  }

  static logout() {
    html.window.sessionStorage.remove(AUTH_CODE_VERIFIER_KEY);
    html.window.sessionStorage.remove(AUTH_CODE_KEY);
    html.window.sessionStorage.remove(AUTH_ACCESS_TOKEN_KEY);
    html.window.sessionStorage.remove(AUTH_ACCESS_TOKEN_EXPIRE);
    html.window.sessionStorage.remove(AUTH_REFRESH_TOKEN_KEY);
    html.window.sessionStorage.remove(AUTH_DESTINATION_URL);
    locator<ApiClient>().setAuthentication(REALM, null);
    // var logoutUri = LOGOUT_URL + "?redirect_uri=${Uri.encodeQueryComponent(CALLBACK_URL)}";
    html.window.location.assign(LOGOUT_URL);
  }

  static refreshToken() async {
    var tokenExpiration = DateTime.parse(html.window.sessionStorage[AUTH_ACCESS_TOKEN_EXPIRE]);
    var expireIn = tokenExpiration.difference(DateTime.now());

    // print("Token expires in ${expireIn}");

    if (expireIn.inMinutes < 1) {
      var token = await requestToken(GRANT_REFRESH);
      addTokenToApiClient(token);
    }
  }

  static getDioDelegate() {
    var dioDelegate = DioClientDelegate();
    dioDelegate.client.interceptors.add(InterceptorsWrapper(
        onRequest: (options) async {
          await Oauth.refreshToken();
        }
    ));
  }

  static bool isLoggedIn() {
    return html.window.sessionStorage[AUTH_ACCESS_TOKEN_KEY] != null && html.window.sessionStorage[AUTH_ACCESS_TOKEN_KEY].isNotEmpty;
  }
}