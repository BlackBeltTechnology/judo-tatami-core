{{log 'Oauth generation for' (variable application.name) level='info'}}
//////////////////////////////////////////////////////////////////////////////
// G E N E R A T E D    C L A S S
// ------------------------------
// Factory expression: {{{ cleanup template.factoryExpression }}}
// Path expression: {{{ cleanup template.pathExpression }}}
// Overwrite: {{{ cleanup template.overwriteExpression }}}
// Template name: {{ template.templateName }}
// Application: {{ application.name }}

// ignore: avoid_web_libraries_in_flutter
import 'dart:convert';
import 'dart:html' as html;

import 'package:dartz/dartz.dart';
import 'package:dio/dio.dart';
import 'package:{{ modelPackage application.name }}/{{ path application.name }}/error/error_handler.dart';
import 'package:{{ modelPackage application.name }}/{{ path application.name }}/repository/package.dart';
import 'package:flutter_appauth_platform_interface/flutter_appauth_platform_interface.dart';
import 'package:flutter_appauth_web/flutter_appauth_web.dart';
import 'package:mobx/mobx.dart';
import 'package:openapi_dart_common/openapi.dart';
import 'injector/injector.dart';
import 'dart:async';
import 'package:http/http.dart' as http;

import 'package:{{ modelPackage application.name }}/{{ path application.name }}/rest/lib/api.dart';

part 'oauth.g.dart';

class Oauth {
  static const AUTH_CODE_VERIFIER_KEY = "auth_code_verifier";
  static const AUTH_CODE_KEY = "auth_code";
  static const AUTH_ACCESS_TOKEN_KEY = "auth_access_token";
  static const AUTH_ACCESS_TOKEN_EXPIRE = "auth_access_token_expire";
  static const AUTH_REFRESH_TOKEN_KEY = "auth_refresh_token";
  static const AUTH_DESTINATION_URL = "auth_destination_url";
  static const GRANT_AUTHORIZATION = "authorization_code";
  static const GRANT_REFRESH = "refresh_token";

  //Judo specific
  //static const ISSUER = "http://localhost:8080/auth/realms/JUDO";
  //static const SCOPES = ["email"];
  //static const CALLBACK_URL = "http://localhost:8888/";
  //static const CLIENT_ID = "Judo_Default_Project-User";
  //static const REALM = "JUDO";
  //static const LOGOUT_URL = "http://localhost:8080/auth/realms/JUDO/protocol/openid-connect/logout?redirect_uri=http%3A%2F%2Flocalhost%3A8888%2F";

  static {{ modelName application.name }}{{ packageName application.name }}MetadataSecurityFor{{ className application.name }} securitySettings = {{ modelName application.name }}{{ packageName application.name }}MetadataSecurityFor{{ className application.name }}();
  static var authInfo = AuthInfoStore();

  static String calculateRedirectUri() {
    var callbackUrl = html.window.location.href; //protocol  + "//" + html.window.location.host;
    var uri = Uri.parse(callbackUrl);
    var strippedUri = Uri(scheme: uri.scheme, userInfo: uri.userInfo, host: uri.host, port: uri.port, path: uri.path);
    return strippedUri.toString();
  }

  static loadClientMetaData() async {
    try {
        //TODO remove when openAPI security is set correctly
       // var response = await http.get("http://localhost:8181/api/{{ modelPackage application.name }}/{{ className application.name }}/~meta");
       // final Map<String, dynamic> jsonResponse = jsonDecode(response.body);
       //if (response.statusCode == 200) {
       // var securities =  cast<List>(jsonResponse["security"]);
       // if(securities.isNotEmpty) {
       //     var securityMeta = securities.first;
       //     securitySettings.clientId = securityMeta["clientId"].toString();
       //     securitySettings.clientBaseUrl = securityMeta["clientBaseUrl"].toString();
       //     securitySettings.defaultScopes = securityMeta["defaultScopes"].toString();
       //     securitySettings.issuer = securityMeta["issuer"].toString();
       //     securitySettings.name = securityMeta["name"].toString();
       //     print("security settings: $securitySettings");
       // }
   // }
        try {
            await DefaultApi(
            locator<ApiClient>()).{{ modelNameVariable application.name }}{{ packageName application.name }}{{ className application.name }}Metadata();
        } on ArgumentError catch (error) {
            var realm = error.message.toString().substring(26);
            locator<ApiClient>().setAuthentication(realm, NoopAuth());
        }

            {{ modelName application.name }}{{ packageName application.name }}MetadataFor{{ className application.name }} meta = await DefaultApi(
            locator<ApiClient>()).{{ modelNameVariable application.name }}{{ packageName application.name }}{{ className application.name }}Metadata();
        if (meta.security.isNotEmpty) {
            securitySettings = meta.security.first;
        }
        print("Security settings: $securitySettings");

    } on ApiException catch (error) {
        print(error);
        throw error;
    }
  }

  static bool isAuthenticationRequired() {
        return securitySettings.clientId != null;
  }

  static Future<String> processLogin() async {
    if (!isLoggedIn()) {
      var authResponse = AppAuthWebPlugin.processLoginResult(
          html.window.location.href,
          html.window.sessionStorage[AUTH_CODE_VERIFIER_KEY]);

      if (authResponse != null) {
          html.window.sessionStorage[AUTH_CODE_KEY] = authResponse.authorizationCode;
          return await requestToken(GRANT_AUTHORIZATION);
      }
      return null;
    }
    return html.window.sessionStorage[AUTH_ACCESS_TOKEN_KEY];
  }

  static Future loginAuthorizeAndExchangeCode() async {
    if (html.window.sessionStorage[AUTH_CODE_VERIFIER_KEY] == null || html.window.sessionStorage[AUTH_CODE_VERIFIER_KEY].isEmpty) {
      var auth = AppAuthWebPlugin();
      var request = AuthorizationTokenRequest(
          securitySettings.clientId,
          calculateRedirectUri(),
          issuer: securitySettings.issuer,
          scopes: [securitySettings.defaultScopes]);
      await auth.authorizeAndExchangeCode(request);
    }
  }

  static Future<String> requestToken(String grantType) async {
        // print("authResponse: ${authResponse.authorizationCode}");
        var tokenRequest = TokenRequest(
            securitySettings.clientId,
            calculateRedirectUri(),
            scopes: [securitySettings.defaultScopes],
            grantType: grantType,
            authorizationCode: html.window.sessionStorage[AUTH_CODE_KEY],
            codeVerifier: html.window.sessionStorage[AUTH_CODE_VERIFIER_KEY],
            refreshToken: grantType == GRANT_REFRESH ? html.window.sessionStorage[AUTH_REFRESH_TOKEN_KEY]: null,
            issuer: securitySettings.issuer);

        var token = await AppAuthWebPlugin.requestToken(tokenRequest).catchError((onError) {
            if (onError is ArgumentError && onError.message.toString().contains('token_failed')) {
                authInfo.setAuthenticated(false);
                logout();
                loginAuthorizeAndExchangeCode();
            } else {
                ErrorHandler.navigateToErrorPage(onError);
            }
        });
        if (token != null) {
            html.window.sessionStorage[AUTH_ACCESS_TOKEN_KEY] = token.accessToken;
            html.window.sessionStorage[AUTH_ACCESS_TOKEN_EXPIRE] = token.accessTokenExpirationDateTime.toString();
            html.window.sessionStorage[AUTH_REFRESH_TOKEN_KEY] = token.refreshToken;

            udpateAuthInfo(token.accessToken);

              // print('Access token: ${token.accessToken}');
            // print('Refresh token: ${token.refreshToken}');
            // print(token.accessTokenExpirationDateTime);

            return token.accessToken;
        }
        return null;
  }

  static addTokenToApiClient(String token) {
    if (token != null) {
      locator<ApiClient>().setAuthentication(securitySettings.name, OAuth(accessToken: token));
    }
  }

  static udpateAuthInfo(String token) {
    if (token != null) {
      authInfo.setAuthenticated(true);
      var parsed = parseJwt(token);
      print("Access Token: " + parsed.toString());
      authInfo.setUserName(parsed['preferred_username']);
      authInfo.setEmail(parsed['email']);
    } else {
      authInfo.setAuthenticated(false);
      authInfo.setUserName(null);
      authInfo.setEmail(null);
    }
  }

  static logout() {
    authInfo.setAuthenticated(false);
    html.window.sessionStorage.remove(AUTH_CODE_VERIFIER_KEY);
    html.window.sessionStorage.remove(AUTH_CODE_KEY);
    html.window.sessionStorage.remove(AUTH_ACCESS_TOKEN_KEY);
    html.window.sessionStorage.remove(AUTH_ACCESS_TOKEN_EXPIRE);
    html.window.sessionStorage.remove(AUTH_REFRESH_TOKEN_KEY);
    html.window.sessionStorage.remove(AUTH_DESTINATION_URL);
    locator<ApiClient>().setAuthentication(securitySettings.name, null);
    // var logoutUri = LOGOUT_URL + "?redirect_uri=${Uri.encodeQueryComponent(CALLBACK_URL)}";
    html.window.location.assign(securitySettings.logoutEndpoint + "?redirect_uri=${Uri.encodeQueryComponent(calculateRedirectUri())}");
    securitySettings = {{ modelName application.name }}{{ packageName application.name }}MetadataSecurityFor{{ className application.name }}();
  }

  static refreshToken() async {
    var tokenExpiration = DateTime.parse(html.window.sessionStorage[AUTH_ACCESS_TOKEN_EXPIRE]);
    var expireIn = tokenExpiration.difference(DateTime.now());

    // print("Token expires in ${expireIn}");

    if (expireIn.inMinutes < 1) {
      var token = await requestToken(GRANT_REFRESH);
      await addTokenToApiClient(token);
      return token;
    }
    return null;
  }

  static DioClientDelegate getDioDelegate() {
    var dioDelegate = DioClientDelegate();
    dioDelegate.client.interceptors.add(InterceptorsWrapper(
        onRequest: (options) async {
          var token = await Oauth.refreshToken();
          if (token != null) {
            options.headers.remove('Authorization');
            options.headers.putIfAbsent('Authorization', () => 'Bearer $token');
          }
        }
    ));
    return dioDelegate;
  }

  static bool isLoggedIn() {
    return html.window.sessionStorage[AUTH_ACCESS_TOKEN_KEY] != null && html.window.sessionStorage[AUTH_ACCESS_TOKEN_KEY].isNotEmpty;
  }

  static Future<void> checkPrincipal() async {
    {{# if application.principal }}
    {{ fqClass application.name }}Repository _actorRepository = locator<{{ fqClass application.name }}Repository>();

    try {
      var principal = await _actorRepository.getPrincipal();
      if (principal.email.isNotEmpty) {
        authInfo.setIsPrincipalAllowed(true);
      } else {
        authInfo.setIsPrincipalAllowed(false);
      }
    } catch(error) {
      authInfo.setIsPrincipalAllowed(false);
    }
    {{else}}
    authInfo.setIsPrincipalAllowed(true);
    {{/if}}
  }
}

class NoopAuth implements Authentication {
    void applyToParams(
    List<QueryParam> queryParams, Map<String, dynamic> headerParams) {
        headerParams["Authorization"] = null;
    }
}


class AuthInfoStore extends _AuthInfoStore
    with _$AuthInfoStore {
  AuthInfoStore() : super();
}

abstract class _AuthInfoStore with Store {


  @observable
  bool authenticated ;

  @observable
  String userName;

  @observable
  String email;

  @observable
  bool isPrincipalAllowed;

  @computed
  bool get loggedIn {
    if (authenticated != null && authenticated) {
      return true;
    }
    return false;
  }

  @action
  void setAuthenticated(bool authenticated) {
    this.authenticated = authenticated;
  }

  @action
  void setUserName(String userName) {
    this.userName = userName;
  }

  @action
  void setEmail(String email) {
    this.email = email;
  }

  @action
  void setIsPrincipalAllowed(bool allowed) {
    this.isPrincipalAllowed = allowed;
  }

}


Map<String, dynamic> parseJwt(String token) {
  final parts = token.split('.');
  if (parts.length != 3) {
    throw Exception('invalid token');
  }

  final payload = _decodeBase64(parts[1]);
  final payloadMap = json.decode(payload);
  if (payloadMap is! Map<String, dynamic>) {
    print('invalid payload');
  }

  return payloadMap;
}

String _decodeBase64(String str) {
  String output = str.replaceAll('-', '+').replaceAll('_', '/');

  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += '==';
      break;
    case 3:
      output += '=';
      break;
    default:
      print('Illegal base64url string!"');
  }

  return utf8.decode(base64Url.decode(output));
}