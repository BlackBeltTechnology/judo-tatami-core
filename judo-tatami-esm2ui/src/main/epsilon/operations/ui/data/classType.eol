operation UI!ui::data::ClassType calculateRepresentation() {
    if (self.representation.isUndefined()) {
        var rep = self.attributes.selectOne(a | a.dataType.isKindOf(UI!ui::data::StringType));
        if (rep.isUndefined()) {
            rep = self.attributes.first;
        }
        if (rep.isDefined()) {
            self.representation = rep;
        }
    }
}

operation UI!ui::data::ClassType setRelationTargetsOptional() {
    for (target in
            self.relations
                .select(r | 
                    (r.relationKind == UI!ui::data::RelationKind#AGGREGATION or r.relationKind == UI!ui::data::RelationKind#COMPOSITION) and
                    r.memberType <> UI!ui::data::MemberType#DERIVED and
                    not r.target.isOptional)
                .collect(r | r.target)) {
        target.isOptional = true;
        target.setRelationTargetsOptional();
    }
}
operation UI!ui::data::ClassType setIsForCreateOrUpdateTypeFlag() {
    for (target in self.relations
                .select(r | 
                    (r.relationKind == UI!ui::data::RelationKind#COMPOSITION or r.relationKind == UI!ui::data::RelationKind#AGGREGATION) and
                    not (r.memberType == UI!ui::data::MemberType#TRANSIENT or r.memberType == UI!ui::data::MemberType#DERIVED) and
                    not r.target.isForCreateOrUpdateType)
                .collect(r | r.target)) {
        target.isForCreateOrUpdateType = true;
        target.setIsForCreateOrUpdateTypeFlag();
    }
    return false;
}

operation UI!ui::data::ClassType collectExposedTransferObjects(collected : Set) {
    var newObjects = new Set();
    for (relation in self.relations) {
        if (not collected.includes(relation.target)) {
            newObjects.add(relation.target);
        }
    }
    for (op in self.operations) {
        if (op.input.isDefined() and not collected.includes(op.input.target)) {
            newObjects.add(op.input.target);
        }
        if (op.output.isDefined() and not collected.includes(op.output.target)) {
            newObjects.add(op.output.target);
        }
    }
    
    collected.addAll(newObjects);
    
    for (o in newObjects) {
        o.collectExposedTransferObjects(collected);
    }
}