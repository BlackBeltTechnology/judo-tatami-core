operation ESM!TransferAttribute resolveMixinsForTA() : null {
	for (dependency in esmUtils.getMixin(self.eContainer).dependencies) {
	      log.debug("[TA] Processing mixin dependency" + dependency);
	      if (dependency.attributes.forAll(a | a.name <> self.name)) {
	          if (dependency.isMapped()) {
	              dependency.equivalent("CreateMappedTransferObjectType").attributes.add(self.newDumbTA());
	          } else {
	              dependency.equivalent("CreateUnmappedTransferObjectType").attributes.add(self.newDumbTA());
	          }
	      }
	  }
}

operation ESM!TransferRelation resolveMixinsForTOR() : null {
	for (dependency in esmUtils.getMixin(self.eContainer).dependencies) {
	      log.debug("[TOR] Processing mixin dependency" + dependency);
	      if (dependency.relations.forAll(a | a.name <> self.name)) {
	          if (dependency.isMapped()) {
	              dependency.equivalent("CreateMappedTransferObjectType").relations.add(self.newDumbTOR());
	          } else {
	              dependency.equivalent("CreateUnmappedTransferObjectType").relations.add(self.newDumbTOR());
	          }
	      }
	  }
}

operation ESM!TransferAttribute newDumbTA() : JUDOPSM!TransferAttribute {
	var newTA : JUDOPSM!TransferAttribute = new JUDOPSM!TransferAttribute;
	newTA.name = self.name;
	newTA.required = self.required;
	newTA.dataType = self.dataType.getPSMEquivalent();
	if ( self.primitiveTypedElement.isTypeOf(ESM!DataProperty) ) {
		newTA.binding = self.primitiveTypedElement.equivalent("CreateDataProperty");
	} else {
		newTA.binding = self.primitiveTypedElement.equivalent("CreateAttribute");
	}
	return newTA;
}

operation ESM!TransferRelation newDumbCardinality() : JUDOPSM!Cardinality {
	var dumbCardinality = new JUDOPSM!Cardinality;
	dumbCardinality.lower = self.lower;
	dumbCardinality.upper = self.upper;
	return dumbCardinality; 
}

operation ESM!TransferRelation newDumbTOR() : JUDOPSM!TransferObjectRelation {
	var newTOR = new JUDOPSM!TransferObjectRelation; 
	newTOR.name = self.name;
	newTOR.target = self.target.getPSMEquivalent();
	newTOR.embedded = self.embedded;
	newTOR.cardinality = self.newDumbCardinality();
	
	if (self.referenceTypedElement.isTypeOf(ESM!OneWayEndpoint)) {
		if (self.referenceTypedElement.containment) {
			newTOR.binding = self.referenceTypedElement.equivalent("CreateContainment");
	  	} else {
	  		newTOR.binding = self.referenceTypedElement.equivalent("CreateOneWayEndpoint");
	  	}
	} else if (self.referenceTypedElement.isTypeOf(ESM!TwoWayEndpoint)) {
		newTOR.binding = self.referenceTypedElement.equivalent("CreateTwoWayEndpoint");
	} else if (self.referenceTypedElement.isTypeOf(ESM!StaticNavigation)) {
		newTOR.binding = self.referenceTypedElement.equivalent("CreateStaticNavigation");
	} else if (self.referenceTypedElement.isTypeOf(ESM!NavigationProperty)) {
		newTOR.binding = self.referenceTypedElement.equivalent("CreateNavigationProperty");
	} else {
		log.warn("[newDumbTOR()] Unrecognized referenceTypedElement: " + self.referenceTypedElement);
	}
	return newTOR;
}

//TODO: check after fixing mixin operation fix in mixins in transferObjectType.etl
operation ESM!BoundOperation newDumbOper() : JUDOPSM!BoundOperation {
	var newOper : JUDOPSM!BoundOperation = new JUDOPSM!BoundOperation;
	newOper.name = self.name;
	newOper.body = self.body;
	newOper.output = self.output.equivalent("CreateParameter"); //might be problematic
	newOper.input = self.input.equivalent("CreateParameter"); //might be problematic
	newOper.stateful = true;
	newOper.undefined = self.undefined;
	return newOper;
}

/*------------ TOTs -----------------*/
operation ESM!TransferObjectType isMapped() : Boolean {
	return self.entityType.isDefined();
} 

operation ESM!TransferObjectType getPSMEquivalent() : JUDOPSM!TransferObjectType {
	if(self.isMapped()) {
		return self.equivalent("CreateMappedTransferObjectType");
	} else {
		return self.equivalent("CreateUnmappedTransferObjectType");
	}
}

/*------------ PARAMETER -----------------*/
//[non-equivalent()-function]
operation ESM!Parameter isInput() : Boolean {
	return ( not (ESM!Operation.all.selectOne(op | op.input = self) == null) );
}    

//[non-equivalent()-function]
operation ESM!Parameter isOutput() : Boolean {
	return ( not (ESM!Operation.all.selectOne(op | op.output = self) == null) );
}

//[non-equivalent()-function]
operation ESM!Parameter isFault() : Boolean {
	return ( not (ESM!Operation.all.selectOne(op | op.faults.includes(self)) == null) );
}


operation ESM!Parameter getInputPSMEquivalent() : JUDOPSM!Operation {
	var esmOP : ESM!Operation = ESM!Operation.all.selectOne(op | op.input = self);
	return esmOP.getPSMEquivalent();
}

operation ESM!Parameter getOutputPSMEquivalent() : JUDOPSM!Operation {
	var esmOP : ESM!Operation = ESM!Operation.all.selectOne(op | op.output = self);
	return esmOP.getPSMEquivalent();
}  

operation ESM!Parameter getFaultPSMEquivalent() : JUDOPSM!Operation {
	var esmOP : ESM!Operation = ESM!Operation.all.selectOne(op | op.faults.includes(self));
	return esmOP.getPSMEquivalent();
}

operation ESM!Operation getPSMEquivalent(): JUDOPSM!Operation {
	if (self.isTypeOf(ESM!BoundOperation)) {
		return self.equivalent("CreateBoundOperation");
	} else {
		return self.equivalent("CreateUnboundOperation");
	} 
}
//TODO: fix entityReferencePresence in transferObjectType.etl
/*
@cached
operation ESM!EntityReferenceType getPSMEquivalent(): JUDOPSM!EntityReferenceType {
	switch (self) {
		case ESM!EntityReferenceType#REQUIRED : return JUDOPSM!EntityReferenceType#REQUIRED;
		case ESM!EntityReferenceType#OPTIONAL : return JUDOPSM!EntityReferenceType#OPTIONAL;
		case ESM!EntityReferenceType#NOT_SUPPORTED : return JUDOPSM!EntityReferenceType#NOT_SUPPORTED;
		default: throw "Unsupported ESM!EntityReferenceType!";
	}
}
*/

