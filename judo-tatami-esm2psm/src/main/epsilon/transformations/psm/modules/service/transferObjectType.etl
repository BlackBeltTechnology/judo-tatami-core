import "../namespace.etl";
import "../../../../operations/esm/type/_importType.eol";
import "../../../../operations/esm/service/transferObjectType.eol";

@lazy
@greedy
rule CreateCardinalityOfTransferObjectRelation
	transform s: ESM!TransferRelation
	to t: JUDOPSM!Cardinality {
	  t.upper = s.upper;
  	  t.lower = s.lower;
}

@lazy
@greedy
rule CreateCardinalityOfParameter
	transform s: ESM!Parameter
	to t: JUDOPSM!Cardinality {
	  t.upper = s.upper;
  	  t.lower = s.lower;
}

@abstract
rule CreateTransferObjectType
	transform s: ESM!TransferObjectType
	to t: JUDOPSM!TransferObjectType 
	extends CreateNamespaceElement {
	  t.representation = s.representation.equivalent("CreateTransferAttribute");
}

rule CreateUnmappedTransferObjectType
	transform s: ESM!TransferObjectType 
	to t: JUDOPSM!UnmappedTransferObjectType
	extends CreateTransferObjectType {
	  guard: not s.isMapped()
	  log.debug("Created UnmappedTransferObjectType.");
}

rule CreateMappedTransferObjectType
	transform s: ESM!TransferObjectType
	to t: JUDOPSM!MappedTransferObjectType
	extends CreateTransferObjectType {
	  guard: s.isMapped()
	  //[postponed]: fix entityReferencePresence //= s.entityReferencePresence.getPSMEquivalent();
	  t.entityReferencePresence = JUDOPSM!EntityReferenceType#OPTIONAL;
	  t.entityType = s.entityType.equivalent("CreateEntityType");
	  log.debug("Created MappedTransferObjectType.");
}

//TODO: clean
rule CreateTransferAttribute
	transform s: ESM!TransferAttribute
	to t: JUDOPSM!TransferAttribute 
	extends CreateNamedElement {
	  t.required = s.required;
	  t.dataType = s.dataType.getPSMEquivalent();
	  var esmTOT : ESM!TransferObjectType = ESM!TransferObjectType.all.selectOne(tot | tot.attributes.includes(s));	  
	  esmTOT.getPSMEquivalent().attributes.add(t);
	  
	  //MIXIN...
	  for (dependency in esmUtils.getMixin(s.eContainer).dependencies) {
	      log.debug("[TA] Processing mixin dependency" + dependency);
	      
	      if (dependency.attributes.forAll(a | a.name <> s.name)) {
	          log.debug("  - create attribute that is not defined in transfer object type");
	          var depAttribute = new JUDOPSM!TransferAttribute;
	          depAttribute.name = s.name;
	          depAttribute.required = s.required;
	          depAttribute.dataType = s.dataType.getPSMEquivalent();
	          if ( s.primitiveTypedElement.isTypeOf(ESM!DataProperty) ) {
				depAttribute.binding = s.primitiveTypedElement.equivalent("CreateDataProperty");
			  } else {
				depAttribute.binding = s.primitiveTypedElement.equivalent("CreateAttribute");
			  }
	          
	          if (dependency.isMapped()) {
	              dependency.equivalent("CreateMappedTransferObjectType").attributes.add(depAttribute);
	          } else {
	              dependency.equivalent("CreateUnmappedTransferObjectType").attributes.add(depAttribute);
	          }
	      }
	  }
	  
	  log.debug("Created TransferAttribute: " + t.name);
}

//TODO: clean
rule CreateTransferObjectRelation
	transform s: ESM!TransferRelation
	to t: JUDOPSM!TransferObjectRelation
	extends CreateNamedElement {	  
	  t.cardinality = s.equivalent("CreateCardinalityOfTransferObjectRelation");
	  t.embedded = s.embedded;
	  
	  var esmTOT : ESM!TransferObjectType = ESM!TransferObjectType.all.selectOne(tot | tot.relations.includes(s));
	  esmTOT.getPSMEquivalent().relations.add(t);
	  
	  t.target = s.target.getPSMEquivalent();
	  //MIXIN...
	  for (dependency in esmUtils.getMixin(s.eContainer).dependencies) {
	  	log.debug("[TOR] Processing mixin dependency" + dependency);
	  
	  	if (dependency.relations.forAll(a | a.name <> s.name)) {
	  		var depRelation = new JUDOPSM!TransferObjectRelation;
			depRelation.name = s.name;
			depRelation.target = s.target.getPSMEquivalent();
			depRelation.embedded = s.embedded;
			
			var dumbCardinality : JUDOPSM!Cardinality = new JUDOPSM!Cardinality;
			dumbCardinality.lower = s.lower;
			dumbCardinality.upper = s.upper;
			depRelation.cardinality = dumbCardinality;
			if ((s.referenceTypedElement.isTypeOf(ESM!OneWayEndpoint)) and (s.referenceTypedElement.containment)) {
				depRelation.binding = s.referenceTypedElement.equivalent("CreateContainment");
			} else if (s.referenceTypedElement.isTypeOf(ESM!OneWayEndpoint))  {
				depRelation.binding = s.referenceTypedElement.equivalent("CreateOneWayEndpoint");
			} else if (s.referenceTypedElement.isTypeOf(ESM!TwoWayEndpoint)) {
				depRelation.binding = s.referenceTypedElement.equivalent("CreateTwoWayEndpoint");
			} else if (s.referenceTypedElement.isTypeOf(ESM!StaticNavigation)) {
				depRelation.binding = s.referenceTypedElement.equivalent("CreateStaticNavigation");
			} else if (s.referenceTypedElement.isTypeOf(ESM!NavigationProperty)) {
				depRelation.binding = s.referenceTypedElement.equivalent("CreateNavigationProperty");
			} else {
				log.warn("[newDumbTOR()] Unrecognized referenceTypedElement: " + s.referenceTypedElement);
			}	  		
	  		
	  		if (dependency.isMapped()) {
              dependency.equivalent("CreateMappedTransferObjectType").relations.add(depRelation);
            } else {
              dependency.equivalent("CreateUnmappedTransferObjectType").relations.add(depRelation);
            }
	  		
	    }
	  }
	  
	  
	  log.debug("Created TransferObjectRelation: " + t.name);
}

//TODO: MIXIN
@abstract
rule CreateOperation
	transform s: ESM!Operation
	to t: JUDOPSM!Operation {
	  t.body = s.body;
	  t.output = s.output.equivalent("CreateParameter");
	  t.input = s.input.equivalent("CreateParameter");
	  t.stateful = s.name.startsWith("insert"); // FIXME
	  t.undefined = s.undefined; 
}

rule CreateBoundOperation
	transform s: ESM!BoundOperation
	to t: JUDOPSM!BoundOperation
	extends CreateOperation, CreateNamedElement {
	  ESM!TransferObjectType.all.selectOne(tot | tot.operations.includes(s)).getPSMEquivalent().operations.add(t);
	  log.debug("Created BoundOperation: " + t.name);
}

rule CreateUnboundOperation
	transform s: ESM!UnboundOperation
	to t: JUDOPSM!UnboundOperation
	extends CreateOperation, CreateNamespaceElement {
	  ESM!ExposedService.all.selectOne(es | es.`operation` == s).equivalent("CreateExposedService").`operation` = t;
	  log.debug("Created UnboundOperation: " + s.name);
}

//TODO: clean
rule CreateParameter
	transform s : ESM!Parameter
	to t : JUDOPSM!Parameter
	extends CreateNamedElement {
	  t.cardinality = s.equivalent("CreateCardinalityOfParameter");
	    t.type = s.type.getPSMEquivalent();
		var esmOP : ESM!Operation;
		if(s.isInput()) {
			//log.debug("isInput");
			esmOP = ESM!Operation.all.selectOne(op | op.input = s);
			if (esmOP.isTypeOf(ESM!BoundOperation)) {
				//log.debug("input bound");
				esmOP.equivalent("CreateBoundOperation").input = t;
			} else {
				//log.debug("input unbound");
				esmOP.equivalent("CreateUnboundOperation").input = t;
			}
		} else if (s.isOutput()) {
			//log.debug("isOutput");
			esmOP = ESM!Operation.all.selectOne(op | op.output = s);
			if (esmOP.isTypeOf(ESM!BoundOperation)) {
				//log.debug("output bound");
				esmOP.equivalent("CreateBoundOperation").output = t;
			} else {
				//log.debug("output unbound");
				esmOP.equivalent("CreateUnboundOperation").output = t;
			}
		}
		
		if(s.isFault()) {
			//log.debug("isFault");
			esmOP = ESM!Operation.all.selectOne(op | op.faults.includes(s));
			if (esmOP.isTypeOf(ESM!BoundOperation)) {
				//log.debug("fault bound");
				esmOP.equivalent("CreateBoundOperation").faults.add(t);
			} else {
				//log.debug("fault unbound");
				esmOP.equivalent("CreateUnboundOperation").faults.add(t);
			}
		}
	  log.debug("Created Parameter: " + t.name);
}


