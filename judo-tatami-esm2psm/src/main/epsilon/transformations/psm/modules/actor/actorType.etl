import "../namespace/namespace.etl";
import "../derived/referenceAccessor.etl";
import "../../../../operations/_importAll.eol";

@abstract
rule CreateAbstractActorType
	transform s: ESM!ActorType
	to t: JUDOPSM!AbstractActorType
	extends CreateNamespaceElement {
	  t.transferObjectType = s.principal.getPSMTransferObjectTypeEquivalent();
	  s.principal.getPSMTransferObjectTypeEquivalent().actorType = t;
      if (not s.isEffectiveAnonymous()) {
          t.realm = s.realm;
	  }
}

rule CreateActorTypeClaim
    transform s : ESM!Claim
    to t : JUDOPSM!TransferAttribute {
    	guard: not s.eContainer.isEffectiveAnonymous()

        t.name = s.attribute.name;
        t.claimType = s.claimType.asString();
        t.dataType = s.attribute.dataType.getPSMEquivalent();
        t.required = s.attribute.required;

        if (s.attribute.binding.isDefined() and s.attribute.memberType == ESM!MemberType#MAPPED) {
            t.binding = s.attribute.equivalent("CreateTransferAttributeFromBound").binding;
        } else if (s.attribute.eContainer.isKindOf(ESM!EntityType) and s.attribute.memberType == ESM!MemberType#STORED) {
            t.binding = s.attribute.equivalent("CreateAttribute");
        } else if (s.attribute.binding.isDefined() and s.attribute.binding.eContainer.isKindOf(ESM!EntityType) and s.attribute.memberType == ESM!MemberType#STORED) {
            t.binding = s.attribute.equivalent("CreateTransferAttributeFromAttributeForDefaultTransferObjectType").binding;
        } else if (s.attribute.eContainer.isKindOf(ESM!EntityType) and s.attribute.memberType == ESM!MemberType#DERIVED) {
            t.binding = s.attribute.equivalent("CreateDataProperty");
        } else if (s.attribute.eContainer.isTypeOf(ESM!TransferObjectType) and s.attribute.memberType == ESM!MemberType#DERIVED) {
            t.binding = s.attribute.equivalent("CreateDataPropertyForTransferAttributeBinding");
        } else if (s.attribute.memberType <> ESM!MemberType#TRANSIENT) {
            log.error("Unsupported claim attribute: " + esmUtils.getNamespaceElementFQName(s.attribute.eContainer) + "." + s.attribute.name);
        }

        s.eContainer.getPSMEquivalent().attributes.add(t);

        log.debug("Created ActorType Claim: " + t.name);
}

rule CreateActorType
	transform s: ESM!ActorType
	to t: JUDOPSM!ActorType
	extends CreateAbstractActorType {
	  guard: s.principal.isDefined() and not s.principal.isMapped()

	  log.debug("Created ActorType: " + t.name);
}

@lazy
rule CreateMetadataType
	transform s: ESM!ActorType
	to t: JUDOPSM!UnmappedTransferObjectType
	extends CreateNamespaceElement {
	  t.name = "_MetadataFor" + s.name;

      var security = new JUDOPSM!TransferObjectRelation();
      security.name = "security";
	  security.embedded = true;
	  security.cardinality = new JUDOPSM!Cardinality;
      security.cardinality.lower = 0;
      security.cardinality.upper = -1;
      security.target = s.equivalent("CreateMetadataSecurityType");

      t.relations.add(security);
}

@lazy
rule CreateMetadataSecurityType
	transform s: ESM!ActorType
	to t: JUDOPSM!UnmappedTransferObjectType
	extends CreateNamespaceElement {
	  t.name = "_MetadataSecurityFor" + s.name;

	  var m : ESM!Model = ESM!Model.all.first();

      var name = new JUDOPSM!TransferAttribute();
      name.name = "name";
      name.dataType = m.equivalent("CreateAutoGeneratedStringType");
      name.required = true;

      var openIdConfigurationUrl = new JUDOPSM!TransferAttribute();
      openIdConfigurationUrl.name = "openIdConfigurationUrl";
      openIdConfigurationUrl.dataType = m.equivalent("CreateAutoGeneratedStringType");
      openIdConfigurationUrl.required = false;

      var issuer = new JUDOPSM!TransferAttribute();
      issuer.name = "issuer";
      issuer.dataType = m.equivalent("CreateAutoGeneratedStringType");
      issuer.required = false;

      var authEndpoint = new JUDOPSM!TransferAttribute();
      authEndpoint.name = "authEndpoint";
      authEndpoint.dataType = m.equivalent("CreateAutoGeneratedStringType");
      authEndpoint.required = false;

      var tokenEndpoint = new JUDOPSM!TransferAttribute();
      tokenEndpoint.name = "tokenEndpoint";
      tokenEndpoint.dataType = m.equivalent("CreateAutoGeneratedStringType");
      tokenEndpoint.required = false;

      var logoutEndpoint = new JUDOPSM!TransferAttribute();
      logoutEndpoint.name = "logoutEndpoint";
      logoutEndpoint.dataType = m.equivalent("CreateAutoGeneratedStringType");
      logoutEndpoint.required = false;

      var clientId = new JUDOPSM!TransferAttribute();
      clientId.name = "clientId";
      clientId.dataType = m.equivalent("CreateAutoGeneratedStringType");
      clientId.required = true;

      var clientBaseUrl = new JUDOPSM!TransferAttribute();
      clientBaseUrl.name = "clientBaseUrl";
      clientBaseUrl.dataType = m.equivalent("CreateAutoGeneratedStringType");
      clientBaseUrl.required = false;

      var defaultScopes = new JUDOPSM!TransferAttribute();
      defaultScopes.name = "defaultScopes";
      defaultScopes.dataType = m.equivalent("CreateAutoGeneratedStringType");
      defaultScopes.required = true;

	  t.attributes.add(name);
      t.attributes.add(openIdConfigurationUrl);
	  t.attributes.add(issuer);
	  t.attributes.add(authEndpoint);
	  t.attributes.add(tokenEndpoint);
	  t.attributes.add(logoutEndpoint);
	  t.attributes.add(clientId);
	  t.attributes.add(clientBaseUrl);
	  t.attributes.add(defaultScopes);
}

rule CreateMappedActorType
	transform s: ESM!ActorType
	to t: JUDOPSM!MappedActorType
	extends CreateAbstractActorType {
	  guard: s.principal.isDefined() and s.principal.isMapped()

	  t.entityType = s.principal.mapping.target.getPSMEquivalent();
	  t.managed = s.managed;
	  t.kind = s.kind.asString();
	  
	  if (s.isActiveExpression.isDefined() and s.isActiveExpression.trim().length() > 0) {
	      t.filter = s.equivalent("CreateFilterExpressionForMappedActorType");
	  }

	  log.debug("Created ActorType: " + t.name);
}

rule CreateActorTypeWithoutPrincipal
	transform s: ESM!ActorType
	to t: JUDOPSM!ActorType
	extends CreateNamespaceElement {
	  guard: s.principal.isUndefined()
	  
      if (not s.isEffectiveAnonymous()) {
          t.realm = s.realm;
	  }
}

@abstract
rule CreateTransferObjectRelationFromAccess
	transform s: ESM!Access
	to t: JUDOPSM!TransferObjectRelation
	extends CreateNamedElement {
		t.cardinality = s.equivalent("CreateCardinalityForReferenceTypedElement");
		t.access = true;
		t.target = s.target.getPSMTransferObjectTypeEquivalent();
		s.eContainer.getPSMEquivalent().relations.add(t);

    if (s.isCreateAllowed()) {
        t.embeddedCreate = true;
    }
    if (s.isUpdateAllowed()) {
        t.embeddedUpdate = true;
    }
    if (s.isDeleteAllowed()) {
        t.embeddedDelete = true;
    }
	log.debug("Created access relation: " + t.name + " for actor type: " + t.eContainer.name);
}

rule CreateAccessTransferObjectRelationWithoutBinding
    transform s: ESM!Access
    to t: JUDOPSM!TransferObjectRelation
    extends CreateTransferObjectRelationFromAccess {
        guard: s.accessType == ESM!AccessType#ALL
}

rule CreateAccessTransferObjectRelationWithBinding
    transform s: ESM!Access
    to t: JUDOPSM!TransferObjectRelation
    extends CreateTransferObjectRelationFromAccess {
        guard: s.accessType == ESM!AccessType#DERIVED

    t.binding = s.getPSMTransferObjectRelationBindingEquivalent();
}
